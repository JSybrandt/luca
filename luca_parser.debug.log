Grammar:

Rule 0     S' -> block
Rule 1     block -> block NEWLINE
Rule 2     block -> NEWLINE block
Rule 3     block -> block stmt
Rule 4     block -> stmt
Rule 5     stmt -> expr
Rule 6     stmt -> PRINT ( expr )
Rule 7     expr -> ref ASSIGN expr
Rule 8     expr -> ref
Rule 9     expr -> { new_scope }
Rule 10    expr -> { new_scope block }
Rule 11    expr -> NULL
Rule 12    expr -> BOOLEAN
Rule 13    expr -> STRING
Rule 14    expr -> NUMBER
Rule 15    expr -> NOT expr  [precedence=right, level=5]
Rule 16    expr -> expr EQ expr  [precedence=left, level=2]
Rule 17    expr -> expr OR expr  [precedence=left, level=1]
Rule 18    expr -> expr AND expr  [precedence=left, level=1]
Rule 19    expr -> ( expr )
Rule 20    expr -> - expr  [precedence=right, level=5]
Rule 21    expr -> expr % expr  [precedence=left, level=4]
Rule 22    expr -> expr / expr  [precedence=left, level=4]
Rule 23    expr -> expr * expr  [precedence=left, level=4]
Rule 24    expr -> expr - expr  [precedence=left, level=3]
Rule 25    expr -> expr + expr  [precedence=left, level=3]
Rule 26    new_scope -> <empty>
Rule 27    ref -> NAME
Rule 28    ref -> ref . NAME

Unused terminals:

    MOD
    NEQ
    RETURN

Terminals, with rules where they appear:

%                    : 21
(                    : 6 19
)                    : 6 19
*                    : 23
+                    : 25
-                    : 20 24
.                    : 28
/                    : 22
AND                  : 18
ASSIGN               : 7
BOOLEAN              : 12
EQ                   : 16
MOD                  : 
NAME                 : 27 28
NEQ                  : 
NEWLINE              : 1 2
NOT                  : 15
NULL                 : 11
NUMBER               : 14
OR                   : 17
PRINT                : 6
RETURN               : 
STRING               : 13
error                : 
{                    : 9 10
}                    : 9 10

Nonterminals, with rules where they appear:

block                : 1 2 3 10 0
expr                 : 5 6 7 15 16 16 17 17 18 18 19 20 21 21 22 22 23 23 24 24 25 25
new_scope            : 9 10
ref                  : 7 8 28
stmt                 : 3 4


state 0

    (0) S' -> . block
    (1) block -> . block NEWLINE
    (2) block -> . NEWLINE block
    (3) block -> . block stmt
    (4) block -> . stmt
    (5) stmt -> . expr
    (6) stmt -> . PRINT ( expr )
    (7) expr -> . ref ASSIGN expr
    (8) expr -> . ref
    (9) expr -> . { new_scope }
    (10) expr -> . { new_scope block }
    (11) expr -> . NULL
    (12) expr -> . BOOLEAN
    (13) expr -> . STRING
    (14) expr -> . NUMBER
    (15) expr -> . NOT expr
    (16) expr -> . expr EQ expr
    (17) expr -> . expr OR expr
    (18) expr -> . expr AND expr
    (19) expr -> . ( expr )
    (20) expr -> . - expr
    (21) expr -> . expr % expr
    (22) expr -> . expr / expr
    (23) expr -> . expr * expr
    (24) expr -> . expr - expr
    (25) expr -> . expr + expr
    (27) ref -> . NAME
    (28) ref -> . ref . NAME
    NEWLINE         shift and go to state 2
    PRINT           shift and go to state 5
    {               shift and go to state 8
    NULL            shift and go to state 9
    BOOLEAN         shift and go to state 10
    STRING          shift and go to state 11
    NUMBER          shift and go to state 12
    NOT             shift and go to state 13
    (               shift and go to state 6
    -               shift and go to state 14
    NAME            shift and go to state 15

    block                          shift and go to state 1
    stmt                           shift and go to state 3
    expr                           shift and go to state 4
    ref                            shift and go to state 7

state 1

    (0) S' -> block .
    (1) block -> block . NEWLINE
    (3) block -> block . stmt
    (5) stmt -> . expr
    (6) stmt -> . PRINT ( expr )
    (7) expr -> . ref ASSIGN expr
    (8) expr -> . ref
    (9) expr -> . { new_scope }
    (10) expr -> . { new_scope block }
    (11) expr -> . NULL
    (12) expr -> . BOOLEAN
    (13) expr -> . STRING
    (14) expr -> . NUMBER
    (15) expr -> . NOT expr
    (16) expr -> . expr EQ expr
    (17) expr -> . expr OR expr
    (18) expr -> . expr AND expr
    (19) expr -> . ( expr )
    (20) expr -> . - expr
    (21) expr -> . expr % expr
    (22) expr -> . expr / expr
    (23) expr -> . expr * expr
    (24) expr -> . expr - expr
    (25) expr -> . expr + expr
    (27) ref -> . NAME
    (28) ref -> . ref . NAME
    NEWLINE         shift and go to state 16
    PRINT           shift and go to state 5
    {               shift and go to state 8
    NULL            shift and go to state 9
    BOOLEAN         shift and go to state 10
    STRING          shift and go to state 11
    NUMBER          shift and go to state 12
    NOT             shift and go to state 13
    (               shift and go to state 6
    -               shift and go to state 14
    NAME            shift and go to state 15

    stmt                           shift and go to state 17
    expr                           shift and go to state 4
    ref                            shift and go to state 7

state 2

    (2) block -> NEWLINE . block
    (1) block -> . block NEWLINE
    (2) block -> . NEWLINE block
    (3) block -> . block stmt
    (4) block -> . stmt
    (5) stmt -> . expr
    (6) stmt -> . PRINT ( expr )
    (7) expr -> . ref ASSIGN expr
    (8) expr -> . ref
    (9) expr -> . { new_scope }
    (10) expr -> . { new_scope block }
    (11) expr -> . NULL
    (12) expr -> . BOOLEAN
    (13) expr -> . STRING
    (14) expr -> . NUMBER
    (15) expr -> . NOT expr
    (16) expr -> . expr EQ expr
    (17) expr -> . expr OR expr
    (18) expr -> . expr AND expr
    (19) expr -> . ( expr )
    (20) expr -> . - expr
    (21) expr -> . expr % expr
    (22) expr -> . expr / expr
    (23) expr -> . expr * expr
    (24) expr -> . expr - expr
    (25) expr -> . expr + expr
    (27) ref -> . NAME
    (28) ref -> . ref . NAME
    NEWLINE         shift and go to state 2
    PRINT           shift and go to state 5
    {               shift and go to state 8
    NULL            shift and go to state 9
    BOOLEAN         shift and go to state 10
    STRING          shift and go to state 11
    NUMBER          shift and go to state 12
    NOT             shift and go to state 13
    (               shift and go to state 6
    -               shift and go to state 14
    NAME            shift and go to state 15

    block                          shift and go to state 18
    stmt                           shift and go to state 3
    expr                           shift and go to state 4
    ref                            shift and go to state 7

state 3

    (4) block -> stmt .
    NEWLINE         reduce using rule 4 (block -> stmt .)
    PRINT           reduce using rule 4 (block -> stmt .)
    {               reduce using rule 4 (block -> stmt .)
    NULL            reduce using rule 4 (block -> stmt .)
    BOOLEAN         reduce using rule 4 (block -> stmt .)
    STRING          reduce using rule 4 (block -> stmt .)
    NUMBER          reduce using rule 4 (block -> stmt .)
    NOT             reduce using rule 4 (block -> stmt .)
    (               reduce using rule 4 (block -> stmt .)
    -               reduce using rule 4 (block -> stmt .)
    NAME            reduce using rule 4 (block -> stmt .)
    $end            reduce using rule 4 (block -> stmt .)
    }               reduce using rule 4 (block -> stmt .)


state 4

    (5) stmt -> expr .
    (16) expr -> expr . EQ expr
    (17) expr -> expr . OR expr
    (18) expr -> expr . AND expr
    (21) expr -> expr . % expr
    (22) expr -> expr . / expr
    (23) expr -> expr . * expr
    (24) expr -> expr . - expr
    (25) expr -> expr . + expr
  ! shift/reduce conflict for - resolved as shift
    NEWLINE         reduce using rule 5 (stmt -> expr .)
    PRINT           reduce using rule 5 (stmt -> expr .)
    {               reduce using rule 5 (stmt -> expr .)
    NULL            reduce using rule 5 (stmt -> expr .)
    BOOLEAN         reduce using rule 5 (stmt -> expr .)
    STRING          reduce using rule 5 (stmt -> expr .)
    NUMBER          reduce using rule 5 (stmt -> expr .)
    NOT             reduce using rule 5 (stmt -> expr .)
    (               reduce using rule 5 (stmt -> expr .)
    NAME            reduce using rule 5 (stmt -> expr .)
    $end            reduce using rule 5 (stmt -> expr .)
    }               reduce using rule 5 (stmt -> expr .)
    EQ              shift and go to state 19
    OR              shift and go to state 20
    AND             shift and go to state 21
    %               shift and go to state 22
    /               shift and go to state 23
    *               shift and go to state 24
    -               shift and go to state 25
    +               shift and go to state 26


state 5

    (6) stmt -> PRINT . ( expr )
    (               shift and go to state 27


state 6

    (19) expr -> ( . expr )
    (7) expr -> . ref ASSIGN expr
    (8) expr -> . ref
    (9) expr -> . { new_scope }
    (10) expr -> . { new_scope block }
    (11) expr -> . NULL
    (12) expr -> . BOOLEAN
    (13) expr -> . STRING
    (14) expr -> . NUMBER
    (15) expr -> . NOT expr
    (16) expr -> . expr EQ expr
    (17) expr -> . expr OR expr
    (18) expr -> . expr AND expr
    (19) expr -> . ( expr )
    (20) expr -> . - expr
    (21) expr -> . expr % expr
    (22) expr -> . expr / expr
    (23) expr -> . expr * expr
    (24) expr -> . expr - expr
    (25) expr -> . expr + expr
    (27) ref -> . NAME
    (28) ref -> . ref . NAME
    {               shift and go to state 8
    NULL            shift and go to state 9
    BOOLEAN         shift and go to state 10
    STRING          shift and go to state 11
    NUMBER          shift and go to state 12
    NOT             shift and go to state 13
    (               shift and go to state 6
    -               shift and go to state 14
    NAME            shift and go to state 15

    expr                           shift and go to state 28
    ref                            shift and go to state 7

state 7

    (7) expr -> ref . ASSIGN expr
    (8) expr -> ref .
    (28) ref -> ref . . NAME
    ASSIGN          shift and go to state 29
    EQ              reduce using rule 8 (expr -> ref .)
    OR              reduce using rule 8 (expr -> ref .)
    AND             reduce using rule 8 (expr -> ref .)
    %               reduce using rule 8 (expr -> ref .)
    /               reduce using rule 8 (expr -> ref .)
    *               reduce using rule 8 (expr -> ref .)
    -               reduce using rule 8 (expr -> ref .)
    +               reduce using rule 8 (expr -> ref .)
    NEWLINE         reduce using rule 8 (expr -> ref .)
    PRINT           reduce using rule 8 (expr -> ref .)
    {               reduce using rule 8 (expr -> ref .)
    NULL            reduce using rule 8 (expr -> ref .)
    BOOLEAN         reduce using rule 8 (expr -> ref .)
    STRING          reduce using rule 8 (expr -> ref .)
    NUMBER          reduce using rule 8 (expr -> ref .)
    NOT             reduce using rule 8 (expr -> ref .)
    (               reduce using rule 8 (expr -> ref .)
    NAME            reduce using rule 8 (expr -> ref .)
    $end            reduce using rule 8 (expr -> ref .)
    }               reduce using rule 8 (expr -> ref .)
    )               reduce using rule 8 (expr -> ref .)
    .               shift and go to state 30


state 8

    (9) expr -> { . new_scope }
    (10) expr -> { . new_scope block }
    (26) new_scope -> .
    }               reduce using rule 26 (new_scope -> .)
    NEWLINE         reduce using rule 26 (new_scope -> .)
    PRINT           reduce using rule 26 (new_scope -> .)
    {               reduce using rule 26 (new_scope -> .)
    NULL            reduce using rule 26 (new_scope -> .)
    BOOLEAN         reduce using rule 26 (new_scope -> .)
    STRING          reduce using rule 26 (new_scope -> .)
    NUMBER          reduce using rule 26 (new_scope -> .)
    NOT             reduce using rule 26 (new_scope -> .)
    (               reduce using rule 26 (new_scope -> .)
    -               reduce using rule 26 (new_scope -> .)
    NAME            reduce using rule 26 (new_scope -> .)

    new_scope                      shift and go to state 31

state 9

    (11) expr -> NULL .
    EQ              reduce using rule 11 (expr -> NULL .)
    OR              reduce using rule 11 (expr -> NULL .)
    AND             reduce using rule 11 (expr -> NULL .)
    %               reduce using rule 11 (expr -> NULL .)
    /               reduce using rule 11 (expr -> NULL .)
    *               reduce using rule 11 (expr -> NULL .)
    -               reduce using rule 11 (expr -> NULL .)
    +               reduce using rule 11 (expr -> NULL .)
    NEWLINE         reduce using rule 11 (expr -> NULL .)
    PRINT           reduce using rule 11 (expr -> NULL .)
    {               reduce using rule 11 (expr -> NULL .)
    NULL            reduce using rule 11 (expr -> NULL .)
    BOOLEAN         reduce using rule 11 (expr -> NULL .)
    STRING          reduce using rule 11 (expr -> NULL .)
    NUMBER          reduce using rule 11 (expr -> NULL .)
    NOT             reduce using rule 11 (expr -> NULL .)
    (               reduce using rule 11 (expr -> NULL .)
    NAME            reduce using rule 11 (expr -> NULL .)
    $end            reduce using rule 11 (expr -> NULL .)
    }               reduce using rule 11 (expr -> NULL .)
    )               reduce using rule 11 (expr -> NULL .)


state 10

    (12) expr -> BOOLEAN .
    EQ              reduce using rule 12 (expr -> BOOLEAN .)
    OR              reduce using rule 12 (expr -> BOOLEAN .)
    AND             reduce using rule 12 (expr -> BOOLEAN .)
    %               reduce using rule 12 (expr -> BOOLEAN .)
    /               reduce using rule 12 (expr -> BOOLEAN .)
    *               reduce using rule 12 (expr -> BOOLEAN .)
    -               reduce using rule 12 (expr -> BOOLEAN .)
    +               reduce using rule 12 (expr -> BOOLEAN .)
    NEWLINE         reduce using rule 12 (expr -> BOOLEAN .)
    PRINT           reduce using rule 12 (expr -> BOOLEAN .)
    {               reduce using rule 12 (expr -> BOOLEAN .)
    NULL            reduce using rule 12 (expr -> BOOLEAN .)
    BOOLEAN         reduce using rule 12 (expr -> BOOLEAN .)
    STRING          reduce using rule 12 (expr -> BOOLEAN .)
    NUMBER          reduce using rule 12 (expr -> BOOLEAN .)
    NOT             reduce using rule 12 (expr -> BOOLEAN .)
    (               reduce using rule 12 (expr -> BOOLEAN .)
    NAME            reduce using rule 12 (expr -> BOOLEAN .)
    $end            reduce using rule 12 (expr -> BOOLEAN .)
    }               reduce using rule 12 (expr -> BOOLEAN .)
    )               reduce using rule 12 (expr -> BOOLEAN .)


state 11

    (13) expr -> STRING .
    EQ              reduce using rule 13 (expr -> STRING .)
    OR              reduce using rule 13 (expr -> STRING .)
    AND             reduce using rule 13 (expr -> STRING .)
    %               reduce using rule 13 (expr -> STRING .)
    /               reduce using rule 13 (expr -> STRING .)
    *               reduce using rule 13 (expr -> STRING .)
    -               reduce using rule 13 (expr -> STRING .)
    +               reduce using rule 13 (expr -> STRING .)
    NEWLINE         reduce using rule 13 (expr -> STRING .)
    PRINT           reduce using rule 13 (expr -> STRING .)
    {               reduce using rule 13 (expr -> STRING .)
    NULL            reduce using rule 13 (expr -> STRING .)
    BOOLEAN         reduce using rule 13 (expr -> STRING .)
    STRING          reduce using rule 13 (expr -> STRING .)
    NUMBER          reduce using rule 13 (expr -> STRING .)
    NOT             reduce using rule 13 (expr -> STRING .)
    (               reduce using rule 13 (expr -> STRING .)
    NAME            reduce using rule 13 (expr -> STRING .)
    $end            reduce using rule 13 (expr -> STRING .)
    }               reduce using rule 13 (expr -> STRING .)
    )               reduce using rule 13 (expr -> STRING .)


state 12

    (14) expr -> NUMBER .
    EQ              reduce using rule 14 (expr -> NUMBER .)
    OR              reduce using rule 14 (expr -> NUMBER .)
    AND             reduce using rule 14 (expr -> NUMBER .)
    %               reduce using rule 14 (expr -> NUMBER .)
    /               reduce using rule 14 (expr -> NUMBER .)
    *               reduce using rule 14 (expr -> NUMBER .)
    -               reduce using rule 14 (expr -> NUMBER .)
    +               reduce using rule 14 (expr -> NUMBER .)
    NEWLINE         reduce using rule 14 (expr -> NUMBER .)
    PRINT           reduce using rule 14 (expr -> NUMBER .)
    {               reduce using rule 14 (expr -> NUMBER .)
    NULL            reduce using rule 14 (expr -> NUMBER .)
    BOOLEAN         reduce using rule 14 (expr -> NUMBER .)
    STRING          reduce using rule 14 (expr -> NUMBER .)
    NUMBER          reduce using rule 14 (expr -> NUMBER .)
    NOT             reduce using rule 14 (expr -> NUMBER .)
    (               reduce using rule 14 (expr -> NUMBER .)
    NAME            reduce using rule 14 (expr -> NUMBER .)
    $end            reduce using rule 14 (expr -> NUMBER .)
    }               reduce using rule 14 (expr -> NUMBER .)
    )               reduce using rule 14 (expr -> NUMBER .)


state 13

    (15) expr -> NOT . expr
    (7) expr -> . ref ASSIGN expr
    (8) expr -> . ref
    (9) expr -> . { new_scope }
    (10) expr -> . { new_scope block }
    (11) expr -> . NULL
    (12) expr -> . BOOLEAN
    (13) expr -> . STRING
    (14) expr -> . NUMBER
    (15) expr -> . NOT expr
    (16) expr -> . expr EQ expr
    (17) expr -> . expr OR expr
    (18) expr -> . expr AND expr
    (19) expr -> . ( expr )
    (20) expr -> . - expr
    (21) expr -> . expr % expr
    (22) expr -> . expr / expr
    (23) expr -> . expr * expr
    (24) expr -> . expr - expr
    (25) expr -> . expr + expr
    (27) ref -> . NAME
    (28) ref -> . ref . NAME
    {               shift and go to state 8
    NULL            shift and go to state 9
    BOOLEAN         shift and go to state 10
    STRING          shift and go to state 11
    NUMBER          shift and go to state 12
    NOT             shift and go to state 13
    (               shift and go to state 6
    -               shift and go to state 14
    NAME            shift and go to state 15

    expr                           shift and go to state 32
    ref                            shift and go to state 7

state 14

    (20) expr -> - . expr
    (7) expr -> . ref ASSIGN expr
    (8) expr -> . ref
    (9) expr -> . { new_scope }
    (10) expr -> . { new_scope block }
    (11) expr -> . NULL
    (12) expr -> . BOOLEAN
    (13) expr -> . STRING
    (14) expr -> . NUMBER
    (15) expr -> . NOT expr
    (16) expr -> . expr EQ expr
    (17) expr -> . expr OR expr
    (18) expr -> . expr AND expr
    (19) expr -> . ( expr )
    (20) expr -> . - expr
    (21) expr -> . expr % expr
    (22) expr -> . expr / expr
    (23) expr -> . expr * expr
    (24) expr -> . expr - expr
    (25) expr -> . expr + expr
    (27) ref -> . NAME
    (28) ref -> . ref . NAME
    {               shift and go to state 8
    NULL            shift and go to state 9
    BOOLEAN         shift and go to state 10
    STRING          shift and go to state 11
    NUMBER          shift and go to state 12
    NOT             shift and go to state 13
    (               shift and go to state 6
    -               shift and go to state 14
    NAME            shift and go to state 15

    expr                           shift and go to state 33
    ref                            shift and go to state 7

state 15

    (27) ref -> NAME .
    ASSIGN          reduce using rule 27 (ref -> NAME .)
    .               reduce using rule 27 (ref -> NAME .)
    EQ              reduce using rule 27 (ref -> NAME .)
    OR              reduce using rule 27 (ref -> NAME .)
    AND             reduce using rule 27 (ref -> NAME .)
    %               reduce using rule 27 (ref -> NAME .)
    /               reduce using rule 27 (ref -> NAME .)
    *               reduce using rule 27 (ref -> NAME .)
    -               reduce using rule 27 (ref -> NAME .)
    +               reduce using rule 27 (ref -> NAME .)
    NEWLINE         reduce using rule 27 (ref -> NAME .)
    PRINT           reduce using rule 27 (ref -> NAME .)
    {               reduce using rule 27 (ref -> NAME .)
    NULL            reduce using rule 27 (ref -> NAME .)
    BOOLEAN         reduce using rule 27 (ref -> NAME .)
    STRING          reduce using rule 27 (ref -> NAME .)
    NUMBER          reduce using rule 27 (ref -> NAME .)
    NOT             reduce using rule 27 (ref -> NAME .)
    (               reduce using rule 27 (ref -> NAME .)
    NAME            reduce using rule 27 (ref -> NAME .)
    $end            reduce using rule 27 (ref -> NAME .)
    }               reduce using rule 27 (ref -> NAME .)
    )               reduce using rule 27 (ref -> NAME .)


state 16

    (1) block -> block NEWLINE .
    NEWLINE         reduce using rule 1 (block -> block NEWLINE .)
    PRINT           reduce using rule 1 (block -> block NEWLINE .)
    {               reduce using rule 1 (block -> block NEWLINE .)
    NULL            reduce using rule 1 (block -> block NEWLINE .)
    BOOLEAN         reduce using rule 1 (block -> block NEWLINE .)
    STRING          reduce using rule 1 (block -> block NEWLINE .)
    NUMBER          reduce using rule 1 (block -> block NEWLINE .)
    NOT             reduce using rule 1 (block -> block NEWLINE .)
    (               reduce using rule 1 (block -> block NEWLINE .)
    -               reduce using rule 1 (block -> block NEWLINE .)
    NAME            reduce using rule 1 (block -> block NEWLINE .)
    $end            reduce using rule 1 (block -> block NEWLINE .)
    }               reduce using rule 1 (block -> block NEWLINE .)


state 17

    (3) block -> block stmt .
    NEWLINE         reduce using rule 3 (block -> block stmt .)
    PRINT           reduce using rule 3 (block -> block stmt .)
    {               reduce using rule 3 (block -> block stmt .)
    NULL            reduce using rule 3 (block -> block stmt .)
    BOOLEAN         reduce using rule 3 (block -> block stmt .)
    STRING          reduce using rule 3 (block -> block stmt .)
    NUMBER          reduce using rule 3 (block -> block stmt .)
    NOT             reduce using rule 3 (block -> block stmt .)
    (               reduce using rule 3 (block -> block stmt .)
    -               reduce using rule 3 (block -> block stmt .)
    NAME            reduce using rule 3 (block -> block stmt .)
    $end            reduce using rule 3 (block -> block stmt .)
    }               reduce using rule 3 (block -> block stmt .)


state 18

    (2) block -> NEWLINE block .
    (1) block -> block . NEWLINE
    (3) block -> block . stmt
    (5) stmt -> . expr
    (6) stmt -> . PRINT ( expr )
    (7) expr -> . ref ASSIGN expr
    (8) expr -> . ref
    (9) expr -> . { new_scope }
    (10) expr -> . { new_scope block }
    (11) expr -> . NULL
    (12) expr -> . BOOLEAN
    (13) expr -> . STRING
    (14) expr -> . NUMBER
    (15) expr -> . NOT expr
    (16) expr -> . expr EQ expr
    (17) expr -> . expr OR expr
    (18) expr -> . expr AND expr
    (19) expr -> . ( expr )
    (20) expr -> . - expr
    (21) expr -> . expr % expr
    (22) expr -> . expr / expr
    (23) expr -> . expr * expr
    (24) expr -> . expr - expr
    (25) expr -> . expr + expr
    (27) ref -> . NAME
    (28) ref -> . ref . NAME
  ! shift/reduce conflict for NEWLINE resolved as shift
  ! shift/reduce conflict for PRINT resolved as shift
  ! shift/reduce conflict for { resolved as shift
  ! shift/reduce conflict for NULL resolved as shift
  ! shift/reduce conflict for BOOLEAN resolved as shift
  ! shift/reduce conflict for STRING resolved as shift
  ! shift/reduce conflict for NUMBER resolved as shift
  ! shift/reduce conflict for NOT resolved as shift
  ! shift/reduce conflict for ( resolved as shift
  ! shift/reduce conflict for - resolved as shift
  ! shift/reduce conflict for NAME resolved as shift
    $end            reduce using rule 2 (block -> NEWLINE block .)
    }               reduce using rule 2 (block -> NEWLINE block .)
    NEWLINE         shift and go to state 16
    PRINT           shift and go to state 5
    {               shift and go to state 8
    NULL            shift and go to state 9
    BOOLEAN         shift and go to state 10
    STRING          shift and go to state 11
    NUMBER          shift and go to state 12
    NOT             shift and go to state 13
    (               shift and go to state 6
    -               shift and go to state 14
    NAME            shift and go to state 15

    stmt                           shift and go to state 17
    expr                           shift and go to state 4
    ref                            shift and go to state 7

state 19

    (16) expr -> expr EQ . expr
    (7) expr -> . ref ASSIGN expr
    (8) expr -> . ref
    (9) expr -> . { new_scope }
    (10) expr -> . { new_scope block }
    (11) expr -> . NULL
    (12) expr -> . BOOLEAN
    (13) expr -> . STRING
    (14) expr -> . NUMBER
    (15) expr -> . NOT expr
    (16) expr -> . expr EQ expr
    (17) expr -> . expr OR expr
    (18) expr -> . expr AND expr
    (19) expr -> . ( expr )
    (20) expr -> . - expr
    (21) expr -> . expr % expr
    (22) expr -> . expr / expr
    (23) expr -> . expr * expr
    (24) expr -> . expr - expr
    (25) expr -> . expr + expr
    (27) ref -> . NAME
    (28) ref -> . ref . NAME
    {               shift and go to state 8
    NULL            shift and go to state 9
    BOOLEAN         shift and go to state 10
    STRING          shift and go to state 11
    NUMBER          shift and go to state 12
    NOT             shift and go to state 13
    (               shift and go to state 6
    -               shift and go to state 14
    NAME            shift and go to state 15

    expr                           shift and go to state 34
    ref                            shift and go to state 7

state 20

    (17) expr -> expr OR . expr
    (7) expr -> . ref ASSIGN expr
    (8) expr -> . ref
    (9) expr -> . { new_scope }
    (10) expr -> . { new_scope block }
    (11) expr -> . NULL
    (12) expr -> . BOOLEAN
    (13) expr -> . STRING
    (14) expr -> . NUMBER
    (15) expr -> . NOT expr
    (16) expr -> . expr EQ expr
    (17) expr -> . expr OR expr
    (18) expr -> . expr AND expr
    (19) expr -> . ( expr )
    (20) expr -> . - expr
    (21) expr -> . expr % expr
    (22) expr -> . expr / expr
    (23) expr -> . expr * expr
    (24) expr -> . expr - expr
    (25) expr -> . expr + expr
    (27) ref -> . NAME
    (28) ref -> . ref . NAME
    {               shift and go to state 8
    NULL            shift and go to state 9
    BOOLEAN         shift and go to state 10
    STRING          shift and go to state 11
    NUMBER          shift and go to state 12
    NOT             shift and go to state 13
    (               shift and go to state 6
    -               shift and go to state 14
    NAME            shift and go to state 15

    expr                           shift and go to state 35
    ref                            shift and go to state 7

state 21

    (18) expr -> expr AND . expr
    (7) expr -> . ref ASSIGN expr
    (8) expr -> . ref
    (9) expr -> . { new_scope }
    (10) expr -> . { new_scope block }
    (11) expr -> . NULL
    (12) expr -> . BOOLEAN
    (13) expr -> . STRING
    (14) expr -> . NUMBER
    (15) expr -> . NOT expr
    (16) expr -> . expr EQ expr
    (17) expr -> . expr OR expr
    (18) expr -> . expr AND expr
    (19) expr -> . ( expr )
    (20) expr -> . - expr
    (21) expr -> . expr % expr
    (22) expr -> . expr / expr
    (23) expr -> . expr * expr
    (24) expr -> . expr - expr
    (25) expr -> . expr + expr
    (27) ref -> . NAME
    (28) ref -> . ref . NAME
    {               shift and go to state 8
    NULL            shift and go to state 9
    BOOLEAN         shift and go to state 10
    STRING          shift and go to state 11
    NUMBER          shift and go to state 12
    NOT             shift and go to state 13
    (               shift and go to state 6
    -               shift and go to state 14
    NAME            shift and go to state 15

    expr                           shift and go to state 36
    ref                            shift and go to state 7

state 22

    (21) expr -> expr % . expr
    (7) expr -> . ref ASSIGN expr
    (8) expr -> . ref
    (9) expr -> . { new_scope }
    (10) expr -> . { new_scope block }
    (11) expr -> . NULL
    (12) expr -> . BOOLEAN
    (13) expr -> . STRING
    (14) expr -> . NUMBER
    (15) expr -> . NOT expr
    (16) expr -> . expr EQ expr
    (17) expr -> . expr OR expr
    (18) expr -> . expr AND expr
    (19) expr -> . ( expr )
    (20) expr -> . - expr
    (21) expr -> . expr % expr
    (22) expr -> . expr / expr
    (23) expr -> . expr * expr
    (24) expr -> . expr - expr
    (25) expr -> . expr + expr
    (27) ref -> . NAME
    (28) ref -> . ref . NAME
    {               shift and go to state 8
    NULL            shift and go to state 9
    BOOLEAN         shift and go to state 10
    STRING          shift and go to state 11
    NUMBER          shift and go to state 12
    NOT             shift and go to state 13
    (               shift and go to state 6
    -               shift and go to state 14
    NAME            shift and go to state 15

    expr                           shift and go to state 37
    ref                            shift and go to state 7

state 23

    (22) expr -> expr / . expr
    (7) expr -> . ref ASSIGN expr
    (8) expr -> . ref
    (9) expr -> . { new_scope }
    (10) expr -> . { new_scope block }
    (11) expr -> . NULL
    (12) expr -> . BOOLEAN
    (13) expr -> . STRING
    (14) expr -> . NUMBER
    (15) expr -> . NOT expr
    (16) expr -> . expr EQ expr
    (17) expr -> . expr OR expr
    (18) expr -> . expr AND expr
    (19) expr -> . ( expr )
    (20) expr -> . - expr
    (21) expr -> . expr % expr
    (22) expr -> . expr / expr
    (23) expr -> . expr * expr
    (24) expr -> . expr - expr
    (25) expr -> . expr + expr
    (27) ref -> . NAME
    (28) ref -> . ref . NAME
    {               shift and go to state 8
    NULL            shift and go to state 9
    BOOLEAN         shift and go to state 10
    STRING          shift and go to state 11
    NUMBER          shift and go to state 12
    NOT             shift and go to state 13
    (               shift and go to state 6
    -               shift and go to state 14
    NAME            shift and go to state 15

    expr                           shift and go to state 38
    ref                            shift and go to state 7

state 24

    (23) expr -> expr * . expr
    (7) expr -> . ref ASSIGN expr
    (8) expr -> . ref
    (9) expr -> . { new_scope }
    (10) expr -> . { new_scope block }
    (11) expr -> . NULL
    (12) expr -> . BOOLEAN
    (13) expr -> . STRING
    (14) expr -> . NUMBER
    (15) expr -> . NOT expr
    (16) expr -> . expr EQ expr
    (17) expr -> . expr OR expr
    (18) expr -> . expr AND expr
    (19) expr -> . ( expr )
    (20) expr -> . - expr
    (21) expr -> . expr % expr
    (22) expr -> . expr / expr
    (23) expr -> . expr * expr
    (24) expr -> . expr - expr
    (25) expr -> . expr + expr
    (27) ref -> . NAME
    (28) ref -> . ref . NAME
    {               shift and go to state 8
    NULL            shift and go to state 9
    BOOLEAN         shift and go to state 10
    STRING          shift and go to state 11
    NUMBER          shift and go to state 12
    NOT             shift and go to state 13
    (               shift and go to state 6
    -               shift and go to state 14
    NAME            shift and go to state 15

    expr                           shift and go to state 39
    ref                            shift and go to state 7

state 25

    (24) expr -> expr - . expr
    (7) expr -> . ref ASSIGN expr
    (8) expr -> . ref
    (9) expr -> . { new_scope }
    (10) expr -> . { new_scope block }
    (11) expr -> . NULL
    (12) expr -> . BOOLEAN
    (13) expr -> . STRING
    (14) expr -> . NUMBER
    (15) expr -> . NOT expr
    (16) expr -> . expr EQ expr
    (17) expr -> . expr OR expr
    (18) expr -> . expr AND expr
    (19) expr -> . ( expr )
    (20) expr -> . - expr
    (21) expr -> . expr % expr
    (22) expr -> . expr / expr
    (23) expr -> . expr * expr
    (24) expr -> . expr - expr
    (25) expr -> . expr + expr
    (27) ref -> . NAME
    (28) ref -> . ref . NAME
    {               shift and go to state 8
    NULL            shift and go to state 9
    BOOLEAN         shift and go to state 10
    STRING          shift and go to state 11
    NUMBER          shift and go to state 12
    NOT             shift and go to state 13
    (               shift and go to state 6
    -               shift and go to state 14
    NAME            shift and go to state 15

    expr                           shift and go to state 40
    ref                            shift and go to state 7

state 26

    (25) expr -> expr + . expr
    (7) expr -> . ref ASSIGN expr
    (8) expr -> . ref
    (9) expr -> . { new_scope }
    (10) expr -> . { new_scope block }
    (11) expr -> . NULL
    (12) expr -> . BOOLEAN
    (13) expr -> . STRING
    (14) expr -> . NUMBER
    (15) expr -> . NOT expr
    (16) expr -> . expr EQ expr
    (17) expr -> . expr OR expr
    (18) expr -> . expr AND expr
    (19) expr -> . ( expr )
    (20) expr -> . - expr
    (21) expr -> . expr % expr
    (22) expr -> . expr / expr
    (23) expr -> . expr * expr
    (24) expr -> . expr - expr
    (25) expr -> . expr + expr
    (27) ref -> . NAME
    (28) ref -> . ref . NAME
    {               shift and go to state 8
    NULL            shift and go to state 9
    BOOLEAN         shift and go to state 10
    STRING          shift and go to state 11
    NUMBER          shift and go to state 12
    NOT             shift and go to state 13
    (               shift and go to state 6
    -               shift and go to state 14
    NAME            shift and go to state 15

    expr                           shift and go to state 41
    ref                            shift and go to state 7

state 27

    (6) stmt -> PRINT ( . expr )
    (7) expr -> . ref ASSIGN expr
    (8) expr -> . ref
    (9) expr -> . { new_scope }
    (10) expr -> . { new_scope block }
    (11) expr -> . NULL
    (12) expr -> . BOOLEAN
    (13) expr -> . STRING
    (14) expr -> . NUMBER
    (15) expr -> . NOT expr
    (16) expr -> . expr EQ expr
    (17) expr -> . expr OR expr
    (18) expr -> . expr AND expr
    (19) expr -> . ( expr )
    (20) expr -> . - expr
    (21) expr -> . expr % expr
    (22) expr -> . expr / expr
    (23) expr -> . expr * expr
    (24) expr -> . expr - expr
    (25) expr -> . expr + expr
    (27) ref -> . NAME
    (28) ref -> . ref . NAME
    {               shift and go to state 8
    NULL            shift and go to state 9
    BOOLEAN         shift and go to state 10
    STRING          shift and go to state 11
    NUMBER          shift and go to state 12
    NOT             shift and go to state 13
    (               shift and go to state 6
    -               shift and go to state 14
    NAME            shift and go to state 15

    expr                           shift and go to state 42
    ref                            shift and go to state 7

state 28

    (19) expr -> ( expr . )
    (16) expr -> expr . EQ expr
    (17) expr -> expr . OR expr
    (18) expr -> expr . AND expr
    (21) expr -> expr . % expr
    (22) expr -> expr . / expr
    (23) expr -> expr . * expr
    (24) expr -> expr . - expr
    (25) expr -> expr . + expr
    )               shift and go to state 43
    EQ              shift and go to state 19
    OR              shift and go to state 20
    AND             shift and go to state 21
    %               shift and go to state 22
    /               shift and go to state 23
    *               shift and go to state 24
    -               shift and go to state 25
    +               shift and go to state 26


state 29

    (7) expr -> ref ASSIGN . expr
    (7) expr -> . ref ASSIGN expr
    (8) expr -> . ref
    (9) expr -> . { new_scope }
    (10) expr -> . { new_scope block }
    (11) expr -> . NULL
    (12) expr -> . BOOLEAN
    (13) expr -> . STRING
    (14) expr -> . NUMBER
    (15) expr -> . NOT expr
    (16) expr -> . expr EQ expr
    (17) expr -> . expr OR expr
    (18) expr -> . expr AND expr
    (19) expr -> . ( expr )
    (20) expr -> . - expr
    (21) expr -> . expr % expr
    (22) expr -> . expr / expr
    (23) expr -> . expr * expr
    (24) expr -> . expr - expr
    (25) expr -> . expr + expr
    (27) ref -> . NAME
    (28) ref -> . ref . NAME
    {               shift and go to state 8
    NULL            shift and go to state 9
    BOOLEAN         shift and go to state 10
    STRING          shift and go to state 11
    NUMBER          shift and go to state 12
    NOT             shift and go to state 13
    (               shift and go to state 6
    -               shift and go to state 14
    NAME            shift and go to state 15

    ref                            shift and go to state 7
    expr                           shift and go to state 44

state 30

    (28) ref -> ref . . NAME
    NAME            shift and go to state 45


state 31

    (9) expr -> { new_scope . }
    (10) expr -> { new_scope . block }
    (1) block -> . block NEWLINE
    (2) block -> . NEWLINE block
    (3) block -> . block stmt
    (4) block -> . stmt
    (5) stmt -> . expr
    (6) stmt -> . PRINT ( expr )
    (7) expr -> . ref ASSIGN expr
    (8) expr -> . ref
    (9) expr -> . { new_scope }
    (10) expr -> . { new_scope block }
    (11) expr -> . NULL
    (12) expr -> . BOOLEAN
    (13) expr -> . STRING
    (14) expr -> . NUMBER
    (15) expr -> . NOT expr
    (16) expr -> . expr EQ expr
    (17) expr -> . expr OR expr
    (18) expr -> . expr AND expr
    (19) expr -> . ( expr )
    (20) expr -> . - expr
    (21) expr -> . expr % expr
    (22) expr -> . expr / expr
    (23) expr -> . expr * expr
    (24) expr -> . expr - expr
    (25) expr -> . expr + expr
    (27) ref -> . NAME
    (28) ref -> . ref . NAME
    }               shift and go to state 46
    NEWLINE         shift and go to state 2
    PRINT           shift and go to state 5
    {               shift and go to state 8
    NULL            shift and go to state 9
    BOOLEAN         shift and go to state 10
    STRING          shift and go to state 11
    NUMBER          shift and go to state 12
    NOT             shift and go to state 13
    (               shift and go to state 6
    -               shift and go to state 14
    NAME            shift and go to state 15

    block                          shift and go to state 47
    stmt                           shift and go to state 3
    expr                           shift and go to state 4
    ref                            shift and go to state 7

state 32

    (15) expr -> NOT expr .
    (16) expr -> expr . EQ expr
    (17) expr -> expr . OR expr
    (18) expr -> expr . AND expr
    (21) expr -> expr . % expr
    (22) expr -> expr . / expr
    (23) expr -> expr . * expr
    (24) expr -> expr . - expr
    (25) expr -> expr . + expr
    EQ              reduce using rule 15 (expr -> NOT expr .)
    OR              reduce using rule 15 (expr -> NOT expr .)
    AND             reduce using rule 15 (expr -> NOT expr .)
    %               reduce using rule 15 (expr -> NOT expr .)
    /               reduce using rule 15 (expr -> NOT expr .)
    *               reduce using rule 15 (expr -> NOT expr .)
    -               reduce using rule 15 (expr -> NOT expr .)
    +               reduce using rule 15 (expr -> NOT expr .)
    NEWLINE         reduce using rule 15 (expr -> NOT expr .)
    PRINT           reduce using rule 15 (expr -> NOT expr .)
    {               reduce using rule 15 (expr -> NOT expr .)
    NULL            reduce using rule 15 (expr -> NOT expr .)
    BOOLEAN         reduce using rule 15 (expr -> NOT expr .)
    STRING          reduce using rule 15 (expr -> NOT expr .)
    NUMBER          reduce using rule 15 (expr -> NOT expr .)
    NOT             reduce using rule 15 (expr -> NOT expr .)
    (               reduce using rule 15 (expr -> NOT expr .)
    NAME            reduce using rule 15 (expr -> NOT expr .)
    $end            reduce using rule 15 (expr -> NOT expr .)
    }               reduce using rule 15 (expr -> NOT expr .)
    )               reduce using rule 15 (expr -> NOT expr .)


state 33

    (20) expr -> - expr .
    (16) expr -> expr . EQ expr
    (17) expr -> expr . OR expr
    (18) expr -> expr . AND expr
    (21) expr -> expr . % expr
    (22) expr -> expr . / expr
    (23) expr -> expr . * expr
    (24) expr -> expr . - expr
    (25) expr -> expr . + expr
    EQ              reduce using rule 20 (expr -> - expr .)
    OR              reduce using rule 20 (expr -> - expr .)
    AND             reduce using rule 20 (expr -> - expr .)
    %               reduce using rule 20 (expr -> - expr .)
    /               reduce using rule 20 (expr -> - expr .)
    *               reduce using rule 20 (expr -> - expr .)
    -               reduce using rule 20 (expr -> - expr .)
    +               reduce using rule 20 (expr -> - expr .)
    NEWLINE         reduce using rule 20 (expr -> - expr .)
    PRINT           reduce using rule 20 (expr -> - expr .)
    {               reduce using rule 20 (expr -> - expr .)
    NULL            reduce using rule 20 (expr -> - expr .)
    BOOLEAN         reduce using rule 20 (expr -> - expr .)
    STRING          reduce using rule 20 (expr -> - expr .)
    NUMBER          reduce using rule 20 (expr -> - expr .)
    NOT             reduce using rule 20 (expr -> - expr .)
    (               reduce using rule 20 (expr -> - expr .)
    NAME            reduce using rule 20 (expr -> - expr .)
    $end            reduce using rule 20 (expr -> - expr .)
    }               reduce using rule 20 (expr -> - expr .)
    )               reduce using rule 20 (expr -> - expr .)


state 34

    (16) expr -> expr EQ expr .
    (16) expr -> expr . EQ expr
    (17) expr -> expr . OR expr
    (18) expr -> expr . AND expr
    (21) expr -> expr . % expr
    (22) expr -> expr . / expr
    (23) expr -> expr . * expr
    (24) expr -> expr . - expr
    (25) expr -> expr . + expr
    EQ              reduce using rule 16 (expr -> expr EQ expr .)
    OR              reduce using rule 16 (expr -> expr EQ expr .)
    AND             reduce using rule 16 (expr -> expr EQ expr .)
    NEWLINE         reduce using rule 16 (expr -> expr EQ expr .)
    PRINT           reduce using rule 16 (expr -> expr EQ expr .)
    {               reduce using rule 16 (expr -> expr EQ expr .)
    NULL            reduce using rule 16 (expr -> expr EQ expr .)
    BOOLEAN         reduce using rule 16 (expr -> expr EQ expr .)
    STRING          reduce using rule 16 (expr -> expr EQ expr .)
    NUMBER          reduce using rule 16 (expr -> expr EQ expr .)
    NOT             reduce using rule 16 (expr -> expr EQ expr .)
    (               reduce using rule 16 (expr -> expr EQ expr .)
    NAME            reduce using rule 16 (expr -> expr EQ expr .)
    $end            reduce using rule 16 (expr -> expr EQ expr .)
    }               reduce using rule 16 (expr -> expr EQ expr .)
    )               reduce using rule 16 (expr -> expr EQ expr .)
    %               shift and go to state 22
    /               shift and go to state 23
    *               shift and go to state 24
    -               shift and go to state 25
    +               shift and go to state 26


state 35

    (17) expr -> expr OR expr .
    (16) expr -> expr . EQ expr
    (17) expr -> expr . OR expr
    (18) expr -> expr . AND expr
    (21) expr -> expr . % expr
    (22) expr -> expr . / expr
    (23) expr -> expr . * expr
    (24) expr -> expr . - expr
    (25) expr -> expr . + expr
    OR              reduce using rule 17 (expr -> expr OR expr .)
    AND             reduce using rule 17 (expr -> expr OR expr .)
    NEWLINE         reduce using rule 17 (expr -> expr OR expr .)
    PRINT           reduce using rule 17 (expr -> expr OR expr .)
    {               reduce using rule 17 (expr -> expr OR expr .)
    NULL            reduce using rule 17 (expr -> expr OR expr .)
    BOOLEAN         reduce using rule 17 (expr -> expr OR expr .)
    STRING          reduce using rule 17 (expr -> expr OR expr .)
    NUMBER          reduce using rule 17 (expr -> expr OR expr .)
    NOT             reduce using rule 17 (expr -> expr OR expr .)
    (               reduce using rule 17 (expr -> expr OR expr .)
    NAME            reduce using rule 17 (expr -> expr OR expr .)
    $end            reduce using rule 17 (expr -> expr OR expr .)
    }               reduce using rule 17 (expr -> expr OR expr .)
    )               reduce using rule 17 (expr -> expr OR expr .)
    EQ              shift and go to state 19
    %               shift and go to state 22
    /               shift and go to state 23
    *               shift and go to state 24
    -               shift and go to state 25
    +               shift and go to state 26


state 36

    (18) expr -> expr AND expr .
    (16) expr -> expr . EQ expr
    (17) expr -> expr . OR expr
    (18) expr -> expr . AND expr
    (21) expr -> expr . % expr
    (22) expr -> expr . / expr
    (23) expr -> expr . * expr
    (24) expr -> expr . - expr
    (25) expr -> expr . + expr
    OR              reduce using rule 18 (expr -> expr AND expr .)
    AND             reduce using rule 18 (expr -> expr AND expr .)
    NEWLINE         reduce using rule 18 (expr -> expr AND expr .)
    PRINT           reduce using rule 18 (expr -> expr AND expr .)
    {               reduce using rule 18 (expr -> expr AND expr .)
    NULL            reduce using rule 18 (expr -> expr AND expr .)
    BOOLEAN         reduce using rule 18 (expr -> expr AND expr .)
    STRING          reduce using rule 18 (expr -> expr AND expr .)
    NUMBER          reduce using rule 18 (expr -> expr AND expr .)
    NOT             reduce using rule 18 (expr -> expr AND expr .)
    (               reduce using rule 18 (expr -> expr AND expr .)
    NAME            reduce using rule 18 (expr -> expr AND expr .)
    $end            reduce using rule 18 (expr -> expr AND expr .)
    }               reduce using rule 18 (expr -> expr AND expr .)
    )               reduce using rule 18 (expr -> expr AND expr .)
    EQ              shift and go to state 19
    %               shift and go to state 22
    /               shift and go to state 23
    *               shift and go to state 24
    -               shift and go to state 25
    +               shift and go to state 26


state 37

    (21) expr -> expr % expr .
    (16) expr -> expr . EQ expr
    (17) expr -> expr . OR expr
    (18) expr -> expr . AND expr
    (21) expr -> expr . % expr
    (22) expr -> expr . / expr
    (23) expr -> expr . * expr
    (24) expr -> expr . - expr
    (25) expr -> expr . + expr
    EQ              reduce using rule 21 (expr -> expr % expr .)
    OR              reduce using rule 21 (expr -> expr % expr .)
    AND             reduce using rule 21 (expr -> expr % expr .)
    %               reduce using rule 21 (expr -> expr % expr .)
    /               reduce using rule 21 (expr -> expr % expr .)
    *               reduce using rule 21 (expr -> expr % expr .)
    -               reduce using rule 21 (expr -> expr % expr .)
    +               reduce using rule 21 (expr -> expr % expr .)
    NEWLINE         reduce using rule 21 (expr -> expr % expr .)
    PRINT           reduce using rule 21 (expr -> expr % expr .)
    {               reduce using rule 21 (expr -> expr % expr .)
    NULL            reduce using rule 21 (expr -> expr % expr .)
    BOOLEAN         reduce using rule 21 (expr -> expr % expr .)
    STRING          reduce using rule 21 (expr -> expr % expr .)
    NUMBER          reduce using rule 21 (expr -> expr % expr .)
    NOT             reduce using rule 21 (expr -> expr % expr .)
    (               reduce using rule 21 (expr -> expr % expr .)
    NAME            reduce using rule 21 (expr -> expr % expr .)
    $end            reduce using rule 21 (expr -> expr % expr .)
    }               reduce using rule 21 (expr -> expr % expr .)
    )               reduce using rule 21 (expr -> expr % expr .)


state 38

    (22) expr -> expr / expr .
    (16) expr -> expr . EQ expr
    (17) expr -> expr . OR expr
    (18) expr -> expr . AND expr
    (21) expr -> expr . % expr
    (22) expr -> expr . / expr
    (23) expr -> expr . * expr
    (24) expr -> expr . - expr
    (25) expr -> expr . + expr
    EQ              reduce using rule 22 (expr -> expr / expr .)
    OR              reduce using rule 22 (expr -> expr / expr .)
    AND             reduce using rule 22 (expr -> expr / expr .)
    %               reduce using rule 22 (expr -> expr / expr .)
    /               reduce using rule 22 (expr -> expr / expr .)
    *               reduce using rule 22 (expr -> expr / expr .)
    -               reduce using rule 22 (expr -> expr / expr .)
    +               reduce using rule 22 (expr -> expr / expr .)
    NEWLINE         reduce using rule 22 (expr -> expr / expr .)
    PRINT           reduce using rule 22 (expr -> expr / expr .)
    {               reduce using rule 22 (expr -> expr / expr .)
    NULL            reduce using rule 22 (expr -> expr / expr .)
    BOOLEAN         reduce using rule 22 (expr -> expr / expr .)
    STRING          reduce using rule 22 (expr -> expr / expr .)
    NUMBER          reduce using rule 22 (expr -> expr / expr .)
    NOT             reduce using rule 22 (expr -> expr / expr .)
    (               reduce using rule 22 (expr -> expr / expr .)
    NAME            reduce using rule 22 (expr -> expr / expr .)
    $end            reduce using rule 22 (expr -> expr / expr .)
    }               reduce using rule 22 (expr -> expr / expr .)
    )               reduce using rule 22 (expr -> expr / expr .)


state 39

    (23) expr -> expr * expr .
    (16) expr -> expr . EQ expr
    (17) expr -> expr . OR expr
    (18) expr -> expr . AND expr
    (21) expr -> expr . % expr
    (22) expr -> expr . / expr
    (23) expr -> expr . * expr
    (24) expr -> expr . - expr
    (25) expr -> expr . + expr
    EQ              reduce using rule 23 (expr -> expr * expr .)
    OR              reduce using rule 23 (expr -> expr * expr .)
    AND             reduce using rule 23 (expr -> expr * expr .)
    %               reduce using rule 23 (expr -> expr * expr .)
    /               reduce using rule 23 (expr -> expr * expr .)
    *               reduce using rule 23 (expr -> expr * expr .)
    -               reduce using rule 23 (expr -> expr * expr .)
    +               reduce using rule 23 (expr -> expr * expr .)
    NEWLINE         reduce using rule 23 (expr -> expr * expr .)
    PRINT           reduce using rule 23 (expr -> expr * expr .)
    {               reduce using rule 23 (expr -> expr * expr .)
    NULL            reduce using rule 23 (expr -> expr * expr .)
    BOOLEAN         reduce using rule 23 (expr -> expr * expr .)
    STRING          reduce using rule 23 (expr -> expr * expr .)
    NUMBER          reduce using rule 23 (expr -> expr * expr .)
    NOT             reduce using rule 23 (expr -> expr * expr .)
    (               reduce using rule 23 (expr -> expr * expr .)
    NAME            reduce using rule 23 (expr -> expr * expr .)
    $end            reduce using rule 23 (expr -> expr * expr .)
    }               reduce using rule 23 (expr -> expr * expr .)
    )               reduce using rule 23 (expr -> expr * expr .)


state 40

    (24) expr -> expr - expr .
    (16) expr -> expr . EQ expr
    (17) expr -> expr . OR expr
    (18) expr -> expr . AND expr
    (21) expr -> expr . % expr
    (22) expr -> expr . / expr
    (23) expr -> expr . * expr
    (24) expr -> expr . - expr
    (25) expr -> expr . + expr
    EQ              reduce using rule 24 (expr -> expr - expr .)
    OR              reduce using rule 24 (expr -> expr - expr .)
    AND             reduce using rule 24 (expr -> expr - expr .)
    -               reduce using rule 24 (expr -> expr - expr .)
    +               reduce using rule 24 (expr -> expr - expr .)
    NEWLINE         reduce using rule 24 (expr -> expr - expr .)
    PRINT           reduce using rule 24 (expr -> expr - expr .)
    {               reduce using rule 24 (expr -> expr - expr .)
    NULL            reduce using rule 24 (expr -> expr - expr .)
    BOOLEAN         reduce using rule 24 (expr -> expr - expr .)
    STRING          reduce using rule 24 (expr -> expr - expr .)
    NUMBER          reduce using rule 24 (expr -> expr - expr .)
    NOT             reduce using rule 24 (expr -> expr - expr .)
    (               reduce using rule 24 (expr -> expr - expr .)
    NAME            reduce using rule 24 (expr -> expr - expr .)
    $end            reduce using rule 24 (expr -> expr - expr .)
    }               reduce using rule 24 (expr -> expr - expr .)
    )               reduce using rule 24 (expr -> expr - expr .)
    %               shift and go to state 22
    /               shift and go to state 23
    *               shift and go to state 24


state 41

    (25) expr -> expr + expr .
    (16) expr -> expr . EQ expr
    (17) expr -> expr . OR expr
    (18) expr -> expr . AND expr
    (21) expr -> expr . % expr
    (22) expr -> expr . / expr
    (23) expr -> expr . * expr
    (24) expr -> expr . - expr
    (25) expr -> expr . + expr
    EQ              reduce using rule 25 (expr -> expr + expr .)
    OR              reduce using rule 25 (expr -> expr + expr .)
    AND             reduce using rule 25 (expr -> expr + expr .)
    -               reduce using rule 25 (expr -> expr + expr .)
    +               reduce using rule 25 (expr -> expr + expr .)
    NEWLINE         reduce using rule 25 (expr -> expr + expr .)
    PRINT           reduce using rule 25 (expr -> expr + expr .)
    {               reduce using rule 25 (expr -> expr + expr .)
    NULL            reduce using rule 25 (expr -> expr + expr .)
    BOOLEAN         reduce using rule 25 (expr -> expr + expr .)
    STRING          reduce using rule 25 (expr -> expr + expr .)
    NUMBER          reduce using rule 25 (expr -> expr + expr .)
    NOT             reduce using rule 25 (expr -> expr + expr .)
    (               reduce using rule 25 (expr -> expr + expr .)
    NAME            reduce using rule 25 (expr -> expr + expr .)
    $end            reduce using rule 25 (expr -> expr + expr .)
    }               reduce using rule 25 (expr -> expr + expr .)
    )               reduce using rule 25 (expr -> expr + expr .)
    %               shift and go to state 22
    /               shift and go to state 23
    *               shift and go to state 24


state 42

    (6) stmt -> PRINT ( expr . )
    (16) expr -> expr . EQ expr
    (17) expr -> expr . OR expr
    (18) expr -> expr . AND expr
    (21) expr -> expr . % expr
    (22) expr -> expr . / expr
    (23) expr -> expr . * expr
    (24) expr -> expr . - expr
    (25) expr -> expr . + expr
    )               shift and go to state 48
    EQ              shift and go to state 19
    OR              shift and go to state 20
    AND             shift and go to state 21
    %               shift and go to state 22
    /               shift and go to state 23
    *               shift and go to state 24
    -               shift and go to state 25
    +               shift and go to state 26


state 43

    (19) expr -> ( expr ) .
    EQ              reduce using rule 19 (expr -> ( expr ) .)
    OR              reduce using rule 19 (expr -> ( expr ) .)
    AND             reduce using rule 19 (expr -> ( expr ) .)
    %               reduce using rule 19 (expr -> ( expr ) .)
    /               reduce using rule 19 (expr -> ( expr ) .)
    *               reduce using rule 19 (expr -> ( expr ) .)
    -               reduce using rule 19 (expr -> ( expr ) .)
    +               reduce using rule 19 (expr -> ( expr ) .)
    NEWLINE         reduce using rule 19 (expr -> ( expr ) .)
    PRINT           reduce using rule 19 (expr -> ( expr ) .)
    {               reduce using rule 19 (expr -> ( expr ) .)
    NULL            reduce using rule 19 (expr -> ( expr ) .)
    BOOLEAN         reduce using rule 19 (expr -> ( expr ) .)
    STRING          reduce using rule 19 (expr -> ( expr ) .)
    NUMBER          reduce using rule 19 (expr -> ( expr ) .)
    NOT             reduce using rule 19 (expr -> ( expr ) .)
    (               reduce using rule 19 (expr -> ( expr ) .)
    NAME            reduce using rule 19 (expr -> ( expr ) .)
    $end            reduce using rule 19 (expr -> ( expr ) .)
    }               reduce using rule 19 (expr -> ( expr ) .)
    )               reduce using rule 19 (expr -> ( expr ) .)


state 44

    (7) expr -> ref ASSIGN expr .
    (16) expr -> expr . EQ expr
    (17) expr -> expr . OR expr
    (18) expr -> expr . AND expr
    (21) expr -> expr . % expr
    (22) expr -> expr . / expr
    (23) expr -> expr . * expr
    (24) expr -> expr . - expr
    (25) expr -> expr . + expr
  ! shift/reduce conflict for EQ resolved as shift
  ! shift/reduce conflict for OR resolved as shift
  ! shift/reduce conflict for AND resolved as shift
  ! shift/reduce conflict for % resolved as shift
  ! shift/reduce conflict for / resolved as shift
  ! shift/reduce conflict for * resolved as shift
  ! shift/reduce conflict for - resolved as shift
  ! shift/reduce conflict for + resolved as shift
    NEWLINE         reduce using rule 7 (expr -> ref ASSIGN expr .)
    PRINT           reduce using rule 7 (expr -> ref ASSIGN expr .)
    {               reduce using rule 7 (expr -> ref ASSIGN expr .)
    NULL            reduce using rule 7 (expr -> ref ASSIGN expr .)
    BOOLEAN         reduce using rule 7 (expr -> ref ASSIGN expr .)
    STRING          reduce using rule 7 (expr -> ref ASSIGN expr .)
    NUMBER          reduce using rule 7 (expr -> ref ASSIGN expr .)
    NOT             reduce using rule 7 (expr -> ref ASSIGN expr .)
    (               reduce using rule 7 (expr -> ref ASSIGN expr .)
    NAME            reduce using rule 7 (expr -> ref ASSIGN expr .)
    $end            reduce using rule 7 (expr -> ref ASSIGN expr .)
    }               reduce using rule 7 (expr -> ref ASSIGN expr .)
    )               reduce using rule 7 (expr -> ref ASSIGN expr .)
    EQ              shift and go to state 19
    OR              shift and go to state 20
    AND             shift and go to state 21
    %               shift and go to state 22
    /               shift and go to state 23
    *               shift and go to state 24
    -               shift and go to state 25
    +               shift and go to state 26


state 45

    (28) ref -> ref . NAME .
    ASSIGN          reduce using rule 28 (ref -> ref . NAME .)
    .               reduce using rule 28 (ref -> ref . NAME .)
    EQ              reduce using rule 28 (ref -> ref . NAME .)
    OR              reduce using rule 28 (ref -> ref . NAME .)
    AND             reduce using rule 28 (ref -> ref . NAME .)
    %               reduce using rule 28 (ref -> ref . NAME .)
    /               reduce using rule 28 (ref -> ref . NAME .)
    *               reduce using rule 28 (ref -> ref . NAME .)
    -               reduce using rule 28 (ref -> ref . NAME .)
    +               reduce using rule 28 (ref -> ref . NAME .)
    NEWLINE         reduce using rule 28 (ref -> ref . NAME .)
    PRINT           reduce using rule 28 (ref -> ref . NAME .)
    {               reduce using rule 28 (ref -> ref . NAME .)
    NULL            reduce using rule 28 (ref -> ref . NAME .)
    BOOLEAN         reduce using rule 28 (ref -> ref . NAME .)
    STRING          reduce using rule 28 (ref -> ref . NAME .)
    NUMBER          reduce using rule 28 (ref -> ref . NAME .)
    NOT             reduce using rule 28 (ref -> ref . NAME .)
    (               reduce using rule 28 (ref -> ref . NAME .)
    NAME            reduce using rule 28 (ref -> ref . NAME .)
    $end            reduce using rule 28 (ref -> ref . NAME .)
    }               reduce using rule 28 (ref -> ref . NAME .)
    )               reduce using rule 28 (ref -> ref . NAME .)


state 46

    (9) expr -> { new_scope } .
    EQ              reduce using rule 9 (expr -> { new_scope } .)
    OR              reduce using rule 9 (expr -> { new_scope } .)
    AND             reduce using rule 9 (expr -> { new_scope } .)
    %               reduce using rule 9 (expr -> { new_scope } .)
    /               reduce using rule 9 (expr -> { new_scope } .)
    *               reduce using rule 9 (expr -> { new_scope } .)
    -               reduce using rule 9 (expr -> { new_scope } .)
    +               reduce using rule 9 (expr -> { new_scope } .)
    NEWLINE         reduce using rule 9 (expr -> { new_scope } .)
    PRINT           reduce using rule 9 (expr -> { new_scope } .)
    {               reduce using rule 9 (expr -> { new_scope } .)
    NULL            reduce using rule 9 (expr -> { new_scope } .)
    BOOLEAN         reduce using rule 9 (expr -> { new_scope } .)
    STRING          reduce using rule 9 (expr -> { new_scope } .)
    NUMBER          reduce using rule 9 (expr -> { new_scope } .)
    NOT             reduce using rule 9 (expr -> { new_scope } .)
    (               reduce using rule 9 (expr -> { new_scope } .)
    NAME            reduce using rule 9 (expr -> { new_scope } .)
    $end            reduce using rule 9 (expr -> { new_scope } .)
    }               reduce using rule 9 (expr -> { new_scope } .)
    )               reduce using rule 9 (expr -> { new_scope } .)


state 47

    (10) expr -> { new_scope block . }
    (1) block -> block . NEWLINE
    (3) block -> block . stmt
    (5) stmt -> . expr
    (6) stmt -> . PRINT ( expr )
    (7) expr -> . ref ASSIGN expr
    (8) expr -> . ref
    (9) expr -> . { new_scope }
    (10) expr -> . { new_scope block }
    (11) expr -> . NULL
    (12) expr -> . BOOLEAN
    (13) expr -> . STRING
    (14) expr -> . NUMBER
    (15) expr -> . NOT expr
    (16) expr -> . expr EQ expr
    (17) expr -> . expr OR expr
    (18) expr -> . expr AND expr
    (19) expr -> . ( expr )
    (20) expr -> . - expr
    (21) expr -> . expr % expr
    (22) expr -> . expr / expr
    (23) expr -> . expr * expr
    (24) expr -> . expr - expr
    (25) expr -> . expr + expr
    (27) ref -> . NAME
    (28) ref -> . ref . NAME
    }               shift and go to state 49
    NEWLINE         shift and go to state 16
    PRINT           shift and go to state 5
    {               shift and go to state 8
    NULL            shift and go to state 9
    BOOLEAN         shift and go to state 10
    STRING          shift and go to state 11
    NUMBER          shift and go to state 12
    NOT             shift and go to state 13
    (               shift and go to state 6
    -               shift and go to state 14
    NAME            shift and go to state 15

    stmt                           shift and go to state 17
    expr                           shift and go to state 4
    ref                            shift and go to state 7

state 48

    (6) stmt -> PRINT ( expr ) .
    NEWLINE         reduce using rule 6 (stmt -> PRINT ( expr ) .)
    PRINT           reduce using rule 6 (stmt -> PRINT ( expr ) .)
    {               reduce using rule 6 (stmt -> PRINT ( expr ) .)
    NULL            reduce using rule 6 (stmt -> PRINT ( expr ) .)
    BOOLEAN         reduce using rule 6 (stmt -> PRINT ( expr ) .)
    STRING          reduce using rule 6 (stmt -> PRINT ( expr ) .)
    NUMBER          reduce using rule 6 (stmt -> PRINT ( expr ) .)
    NOT             reduce using rule 6 (stmt -> PRINT ( expr ) .)
    (               reduce using rule 6 (stmt -> PRINT ( expr ) .)
    -               reduce using rule 6 (stmt -> PRINT ( expr ) .)
    NAME            reduce using rule 6 (stmt -> PRINT ( expr ) .)
    $end            reduce using rule 6 (stmt -> PRINT ( expr ) .)
    }               reduce using rule 6 (stmt -> PRINT ( expr ) .)


state 49

    (10) expr -> { new_scope block } .
    EQ              reduce using rule 10 (expr -> { new_scope block } .)
    OR              reduce using rule 10 (expr -> { new_scope block } .)
    AND             reduce using rule 10 (expr -> { new_scope block } .)
    %               reduce using rule 10 (expr -> { new_scope block } .)
    /               reduce using rule 10 (expr -> { new_scope block } .)
    *               reduce using rule 10 (expr -> { new_scope block } .)
    -               reduce using rule 10 (expr -> { new_scope block } .)
    +               reduce using rule 10 (expr -> { new_scope block } .)
    NEWLINE         reduce using rule 10 (expr -> { new_scope block } .)
    PRINT           reduce using rule 10 (expr -> { new_scope block } .)
    {               reduce using rule 10 (expr -> { new_scope block } .)
    NULL            reduce using rule 10 (expr -> { new_scope block } .)
    BOOLEAN         reduce using rule 10 (expr -> { new_scope block } .)
    STRING          reduce using rule 10 (expr -> { new_scope block } .)
    NUMBER          reduce using rule 10 (expr -> { new_scope block } .)
    NOT             reduce using rule 10 (expr -> { new_scope block } .)
    (               reduce using rule 10 (expr -> { new_scope block } .)
    NAME            reduce using rule 10 (expr -> { new_scope block } .)
    $end            reduce using rule 10 (expr -> { new_scope block } .)
    }               reduce using rule 10 (expr -> { new_scope block } .)
    )               reduce using rule 10 (expr -> { new_scope block } .)


Conflicts:

shift/reduce conflict for - in state 4 resolved as shift
shift/reduce conflict for NEWLINE in state 18 resolved as shift
shift/reduce conflict for PRINT in state 18 resolved as shift
shift/reduce conflict for { in state 18 resolved as shift
shift/reduce conflict for NULL in state 18 resolved as shift
shift/reduce conflict for BOOLEAN in state 18 resolved as shift
shift/reduce conflict for STRING in state 18 resolved as shift
shift/reduce conflict for NUMBER in state 18 resolved as shift
shift/reduce conflict for NOT in state 18 resolved as shift
shift/reduce conflict for ( in state 18 resolved as shift
shift/reduce conflict for - in state 18 resolved as shift
shift/reduce conflict for NAME in state 18 resolved as shift
shift/reduce conflict for EQ in state 44 resolved as shift
shift/reduce conflict for OR in state 44 resolved as shift
shift/reduce conflict for AND in state 44 resolved as shift
shift/reduce conflict for % in state 44 resolved as shift
shift/reduce conflict for / in state 44 resolved as shift
shift/reduce conflict for * in state 44 resolved as shift
shift/reduce conflict for - in state 44 resolved as shift
shift/reduce conflict for + in state 44 resolved as shift