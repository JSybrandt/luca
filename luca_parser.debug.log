Grammar:

Rule 0     S' -> block
Rule 1     block -> block NEWLINE
Rule 2     block -> NEWLINE block
Rule 3     block -> block stmt
Rule 4     block -> stmt
Rule 5     stmt -> expr
Rule 6     stmt -> PRINT ( expr )
Rule 7     expr -> expr . NAME
Rule 8     expr -> { new_scope }
Rule 9     expr -> { new_scope block }
Rule 10    expr -> NULL
Rule 11    expr -> BOOLEAN
Rule 12    expr -> STRING
Rule 13    expr -> NUMBER
Rule 14    expr -> NOT expr  [precedence=right, level=5]
Rule 15    expr -> expr EQ expr  [precedence=left, level=2]
Rule 16    expr -> expr OR expr  [precedence=left, level=1]
Rule 17    expr -> expr AND expr  [precedence=left, level=1]
Rule 18    expr -> ( expr )
Rule 19    expr -> - expr  [precedence=right, level=5]
Rule 20    expr -> expr % expr  [precedence=left, level=4]
Rule 21    expr -> expr / expr  [precedence=left, level=4]
Rule 22    expr -> expr * expr  [precedence=left, level=4]
Rule 23    expr -> expr - expr  [precedence=left, level=3]
Rule 24    expr -> expr + expr  [precedence=left, level=3]
Rule 25    expr -> NAME
Rule 26    expr -> NAME ASSIGN expr
Rule 27    new_scope -> <empty>

Unused terminals:

    RETURN
    MOD
    NEQ

Terminals, with rules where they appear:

%                    : 20
(                    : 6 18
)                    : 6 18
*                    : 22
+                    : 24
-                    : 19 23
.                    : 7
/                    : 21
AND                  : 17
ASSIGN               : 26
BOOLEAN              : 11
EQ                   : 15
MOD                  : 
NAME                 : 7 25 26
NEQ                  : 
NEWLINE              : 1 2
NOT                  : 14
NULL                 : 10
NUMBER               : 13
OR                   : 16
PRINT                : 6
RETURN               : 
STRING               : 12
error                : 
{                    : 8 9
}                    : 8 9

Nonterminals, with rules where they appear:

block                : 1 2 3 9 0
expr                 : 5 6 7 14 15 15 16 16 17 17 18 19 20 20 21 21 22 22 23 23 24 24 26
new_scope            : 8 9
stmt                 : 3 4


state 0

    (0) S' -> . block
    (1) block -> . block NEWLINE
    (2) block -> . NEWLINE block
    (3) block -> . block stmt
    (4) block -> . stmt
    (5) stmt -> . expr
    (6) stmt -> . PRINT ( expr )
    (7) expr -> . expr . NAME
    (8) expr -> . { new_scope }
    (9) expr -> . { new_scope block }
    (10) expr -> . NULL
    (11) expr -> . BOOLEAN
    (12) expr -> . STRING
    (13) expr -> . NUMBER
    (14) expr -> . NOT expr
    (15) expr -> . expr EQ expr
    (16) expr -> . expr OR expr
    (17) expr -> . expr AND expr
    (18) expr -> . ( expr )
    (19) expr -> . - expr
    (20) expr -> . expr % expr
    (21) expr -> . expr / expr
    (22) expr -> . expr * expr
    (23) expr -> . expr - expr
    (24) expr -> . expr + expr
    (25) expr -> . NAME
    (26) expr -> . NAME ASSIGN expr
    NEWLINE         shift and go to state 2
    PRINT           shift and go to state 5
    {               shift and go to state 8
    NULL            shift and go to state 9
    BOOLEAN         shift and go to state 10
    STRING          shift and go to state 11
    NUMBER          shift and go to state 12
    NOT             shift and go to state 13
    (               shift and go to state 6
    -               shift and go to state 14
    NAME            shift and go to state 7

    block                          shift and go to state 1
    stmt                           shift and go to state 3
    expr                           shift and go to state 4

state 1

    (0) S' -> block .
    (1) block -> block . NEWLINE
    (3) block -> block . stmt
    (5) stmt -> . expr
    (6) stmt -> . PRINT ( expr )
    (7) expr -> . expr . NAME
    (8) expr -> . { new_scope }
    (9) expr -> . { new_scope block }
    (10) expr -> . NULL
    (11) expr -> . BOOLEAN
    (12) expr -> . STRING
    (13) expr -> . NUMBER
    (14) expr -> . NOT expr
    (15) expr -> . expr EQ expr
    (16) expr -> . expr OR expr
    (17) expr -> . expr AND expr
    (18) expr -> . ( expr )
    (19) expr -> . - expr
    (20) expr -> . expr % expr
    (21) expr -> . expr / expr
    (22) expr -> . expr * expr
    (23) expr -> . expr - expr
    (24) expr -> . expr + expr
    (25) expr -> . NAME
    (26) expr -> . NAME ASSIGN expr
    NEWLINE         shift and go to state 15
    PRINT           shift and go to state 5
    {               shift and go to state 8
    NULL            shift and go to state 9
    BOOLEAN         shift and go to state 10
    STRING          shift and go to state 11
    NUMBER          shift and go to state 12
    NOT             shift and go to state 13
    (               shift and go to state 6
    -               shift and go to state 14
    NAME            shift and go to state 7

    stmt                           shift and go to state 16
    expr                           shift and go to state 4

state 2

    (2) block -> NEWLINE . block
    (1) block -> . block NEWLINE
    (2) block -> . NEWLINE block
    (3) block -> . block stmt
    (4) block -> . stmt
    (5) stmt -> . expr
    (6) stmt -> . PRINT ( expr )
    (7) expr -> . expr . NAME
    (8) expr -> . { new_scope }
    (9) expr -> . { new_scope block }
    (10) expr -> . NULL
    (11) expr -> . BOOLEAN
    (12) expr -> . STRING
    (13) expr -> . NUMBER
    (14) expr -> . NOT expr
    (15) expr -> . expr EQ expr
    (16) expr -> . expr OR expr
    (17) expr -> . expr AND expr
    (18) expr -> . ( expr )
    (19) expr -> . - expr
    (20) expr -> . expr % expr
    (21) expr -> . expr / expr
    (22) expr -> . expr * expr
    (23) expr -> . expr - expr
    (24) expr -> . expr + expr
    (25) expr -> . NAME
    (26) expr -> . NAME ASSIGN expr
    NEWLINE         shift and go to state 2
    PRINT           shift and go to state 5
    {               shift and go to state 8
    NULL            shift and go to state 9
    BOOLEAN         shift and go to state 10
    STRING          shift and go to state 11
    NUMBER          shift and go to state 12
    NOT             shift and go to state 13
    (               shift and go to state 6
    -               shift and go to state 14
    NAME            shift and go to state 7

    block                          shift and go to state 17
    stmt                           shift and go to state 3
    expr                           shift and go to state 4

state 3

    (4) block -> stmt .
    NEWLINE         reduce using rule 4 (block -> stmt .)
    PRINT           reduce using rule 4 (block -> stmt .)
    {               reduce using rule 4 (block -> stmt .)
    NULL            reduce using rule 4 (block -> stmt .)
    BOOLEAN         reduce using rule 4 (block -> stmt .)
    STRING          reduce using rule 4 (block -> stmt .)
    NUMBER          reduce using rule 4 (block -> stmt .)
    NOT             reduce using rule 4 (block -> stmt .)
    (               reduce using rule 4 (block -> stmt .)
    -               reduce using rule 4 (block -> stmt .)
    NAME            reduce using rule 4 (block -> stmt .)
    $end            reduce using rule 4 (block -> stmt .)
    }               reduce using rule 4 (block -> stmt .)


state 4

    (5) stmt -> expr .
    (7) expr -> expr . . NAME
    (15) expr -> expr . EQ expr
    (16) expr -> expr . OR expr
    (17) expr -> expr . AND expr
    (20) expr -> expr . % expr
    (21) expr -> expr . / expr
    (22) expr -> expr . * expr
    (23) expr -> expr . - expr
    (24) expr -> expr . + expr
  ! shift/reduce conflict for - resolved as shift
    NEWLINE         reduce using rule 5 (stmt -> expr .)
    PRINT           reduce using rule 5 (stmt -> expr .)
    {               reduce using rule 5 (stmt -> expr .)
    NULL            reduce using rule 5 (stmt -> expr .)
    BOOLEAN         reduce using rule 5 (stmt -> expr .)
    STRING          reduce using rule 5 (stmt -> expr .)
    NUMBER          reduce using rule 5 (stmt -> expr .)
    NOT             reduce using rule 5 (stmt -> expr .)
    (               reduce using rule 5 (stmt -> expr .)
    NAME            reduce using rule 5 (stmt -> expr .)
    $end            reduce using rule 5 (stmt -> expr .)
    }               reduce using rule 5 (stmt -> expr .)
    .               shift and go to state 18
    EQ              shift and go to state 19
    OR              shift and go to state 20
    AND             shift and go to state 21
    %               shift and go to state 22
    /               shift and go to state 23
    *               shift and go to state 24
    -               shift and go to state 25
    +               shift and go to state 26


state 5

    (6) stmt -> PRINT . ( expr )
    (               shift and go to state 27


state 6

    (18) expr -> ( . expr )
    (7) expr -> . expr . NAME
    (8) expr -> . { new_scope }
    (9) expr -> . { new_scope block }
    (10) expr -> . NULL
    (11) expr -> . BOOLEAN
    (12) expr -> . STRING
    (13) expr -> . NUMBER
    (14) expr -> . NOT expr
    (15) expr -> . expr EQ expr
    (16) expr -> . expr OR expr
    (17) expr -> . expr AND expr
    (18) expr -> . ( expr )
    (19) expr -> . - expr
    (20) expr -> . expr % expr
    (21) expr -> . expr / expr
    (22) expr -> . expr * expr
    (23) expr -> . expr - expr
    (24) expr -> . expr + expr
    (25) expr -> . NAME
    (26) expr -> . NAME ASSIGN expr
    {               shift and go to state 8
    NULL            shift and go to state 9
    BOOLEAN         shift and go to state 10
    STRING          shift and go to state 11
    NUMBER          shift and go to state 12
    NOT             shift and go to state 13
    (               shift and go to state 6
    -               shift and go to state 14
    NAME            shift and go to state 7

    expr                           shift and go to state 28

state 7

    (25) expr -> NAME .
    (26) expr -> NAME . ASSIGN expr
    .               reduce using rule 25 (expr -> NAME .)
    EQ              reduce using rule 25 (expr -> NAME .)
    OR              reduce using rule 25 (expr -> NAME .)
    AND             reduce using rule 25 (expr -> NAME .)
    %               reduce using rule 25 (expr -> NAME .)
    /               reduce using rule 25 (expr -> NAME .)
    *               reduce using rule 25 (expr -> NAME .)
    -               reduce using rule 25 (expr -> NAME .)
    +               reduce using rule 25 (expr -> NAME .)
    NEWLINE         reduce using rule 25 (expr -> NAME .)
    PRINT           reduce using rule 25 (expr -> NAME .)
    {               reduce using rule 25 (expr -> NAME .)
    NULL            reduce using rule 25 (expr -> NAME .)
    BOOLEAN         reduce using rule 25 (expr -> NAME .)
    STRING          reduce using rule 25 (expr -> NAME .)
    NUMBER          reduce using rule 25 (expr -> NAME .)
    NOT             reduce using rule 25 (expr -> NAME .)
    (               reduce using rule 25 (expr -> NAME .)
    NAME            reduce using rule 25 (expr -> NAME .)
    $end            reduce using rule 25 (expr -> NAME .)
    }               reduce using rule 25 (expr -> NAME .)
    )               reduce using rule 25 (expr -> NAME .)
    ASSIGN          shift and go to state 29


state 8

    (8) expr -> { . new_scope }
    (9) expr -> { . new_scope block }
    (27) new_scope -> .
    }               reduce using rule 27 (new_scope -> .)
    NEWLINE         reduce using rule 27 (new_scope -> .)
    PRINT           reduce using rule 27 (new_scope -> .)
    {               reduce using rule 27 (new_scope -> .)
    NULL            reduce using rule 27 (new_scope -> .)
    BOOLEAN         reduce using rule 27 (new_scope -> .)
    STRING          reduce using rule 27 (new_scope -> .)
    NUMBER          reduce using rule 27 (new_scope -> .)
    NOT             reduce using rule 27 (new_scope -> .)
    (               reduce using rule 27 (new_scope -> .)
    -               reduce using rule 27 (new_scope -> .)
    NAME            reduce using rule 27 (new_scope -> .)

    new_scope                      shift and go to state 30

state 9

    (10) expr -> NULL .
    .               reduce using rule 10 (expr -> NULL .)
    EQ              reduce using rule 10 (expr -> NULL .)
    OR              reduce using rule 10 (expr -> NULL .)
    AND             reduce using rule 10 (expr -> NULL .)
    %               reduce using rule 10 (expr -> NULL .)
    /               reduce using rule 10 (expr -> NULL .)
    *               reduce using rule 10 (expr -> NULL .)
    -               reduce using rule 10 (expr -> NULL .)
    +               reduce using rule 10 (expr -> NULL .)
    NEWLINE         reduce using rule 10 (expr -> NULL .)
    PRINT           reduce using rule 10 (expr -> NULL .)
    {               reduce using rule 10 (expr -> NULL .)
    NULL            reduce using rule 10 (expr -> NULL .)
    BOOLEAN         reduce using rule 10 (expr -> NULL .)
    STRING          reduce using rule 10 (expr -> NULL .)
    NUMBER          reduce using rule 10 (expr -> NULL .)
    NOT             reduce using rule 10 (expr -> NULL .)
    (               reduce using rule 10 (expr -> NULL .)
    NAME            reduce using rule 10 (expr -> NULL .)
    $end            reduce using rule 10 (expr -> NULL .)
    }               reduce using rule 10 (expr -> NULL .)
    )               reduce using rule 10 (expr -> NULL .)


state 10

    (11) expr -> BOOLEAN .
    .               reduce using rule 11 (expr -> BOOLEAN .)
    EQ              reduce using rule 11 (expr -> BOOLEAN .)
    OR              reduce using rule 11 (expr -> BOOLEAN .)
    AND             reduce using rule 11 (expr -> BOOLEAN .)
    %               reduce using rule 11 (expr -> BOOLEAN .)
    /               reduce using rule 11 (expr -> BOOLEAN .)
    *               reduce using rule 11 (expr -> BOOLEAN .)
    -               reduce using rule 11 (expr -> BOOLEAN .)
    +               reduce using rule 11 (expr -> BOOLEAN .)
    NEWLINE         reduce using rule 11 (expr -> BOOLEAN .)
    PRINT           reduce using rule 11 (expr -> BOOLEAN .)
    {               reduce using rule 11 (expr -> BOOLEAN .)
    NULL            reduce using rule 11 (expr -> BOOLEAN .)
    BOOLEAN         reduce using rule 11 (expr -> BOOLEAN .)
    STRING          reduce using rule 11 (expr -> BOOLEAN .)
    NUMBER          reduce using rule 11 (expr -> BOOLEAN .)
    NOT             reduce using rule 11 (expr -> BOOLEAN .)
    (               reduce using rule 11 (expr -> BOOLEAN .)
    NAME            reduce using rule 11 (expr -> BOOLEAN .)
    $end            reduce using rule 11 (expr -> BOOLEAN .)
    }               reduce using rule 11 (expr -> BOOLEAN .)
    )               reduce using rule 11 (expr -> BOOLEAN .)


state 11

    (12) expr -> STRING .
    .               reduce using rule 12 (expr -> STRING .)
    EQ              reduce using rule 12 (expr -> STRING .)
    OR              reduce using rule 12 (expr -> STRING .)
    AND             reduce using rule 12 (expr -> STRING .)
    %               reduce using rule 12 (expr -> STRING .)
    /               reduce using rule 12 (expr -> STRING .)
    *               reduce using rule 12 (expr -> STRING .)
    -               reduce using rule 12 (expr -> STRING .)
    +               reduce using rule 12 (expr -> STRING .)
    NEWLINE         reduce using rule 12 (expr -> STRING .)
    PRINT           reduce using rule 12 (expr -> STRING .)
    {               reduce using rule 12 (expr -> STRING .)
    NULL            reduce using rule 12 (expr -> STRING .)
    BOOLEAN         reduce using rule 12 (expr -> STRING .)
    STRING          reduce using rule 12 (expr -> STRING .)
    NUMBER          reduce using rule 12 (expr -> STRING .)
    NOT             reduce using rule 12 (expr -> STRING .)
    (               reduce using rule 12 (expr -> STRING .)
    NAME            reduce using rule 12 (expr -> STRING .)
    $end            reduce using rule 12 (expr -> STRING .)
    }               reduce using rule 12 (expr -> STRING .)
    )               reduce using rule 12 (expr -> STRING .)


state 12

    (13) expr -> NUMBER .
    .               reduce using rule 13 (expr -> NUMBER .)
    EQ              reduce using rule 13 (expr -> NUMBER .)
    OR              reduce using rule 13 (expr -> NUMBER .)
    AND             reduce using rule 13 (expr -> NUMBER .)
    %               reduce using rule 13 (expr -> NUMBER .)
    /               reduce using rule 13 (expr -> NUMBER .)
    *               reduce using rule 13 (expr -> NUMBER .)
    -               reduce using rule 13 (expr -> NUMBER .)
    +               reduce using rule 13 (expr -> NUMBER .)
    NEWLINE         reduce using rule 13 (expr -> NUMBER .)
    PRINT           reduce using rule 13 (expr -> NUMBER .)
    {               reduce using rule 13 (expr -> NUMBER .)
    NULL            reduce using rule 13 (expr -> NUMBER .)
    BOOLEAN         reduce using rule 13 (expr -> NUMBER .)
    STRING          reduce using rule 13 (expr -> NUMBER .)
    NUMBER          reduce using rule 13 (expr -> NUMBER .)
    NOT             reduce using rule 13 (expr -> NUMBER .)
    (               reduce using rule 13 (expr -> NUMBER .)
    NAME            reduce using rule 13 (expr -> NUMBER .)
    $end            reduce using rule 13 (expr -> NUMBER .)
    }               reduce using rule 13 (expr -> NUMBER .)
    )               reduce using rule 13 (expr -> NUMBER .)


state 13

    (14) expr -> NOT . expr
    (7) expr -> . expr . NAME
    (8) expr -> . { new_scope }
    (9) expr -> . { new_scope block }
    (10) expr -> . NULL
    (11) expr -> . BOOLEAN
    (12) expr -> . STRING
    (13) expr -> . NUMBER
    (14) expr -> . NOT expr
    (15) expr -> . expr EQ expr
    (16) expr -> . expr OR expr
    (17) expr -> . expr AND expr
    (18) expr -> . ( expr )
    (19) expr -> . - expr
    (20) expr -> . expr % expr
    (21) expr -> . expr / expr
    (22) expr -> . expr * expr
    (23) expr -> . expr - expr
    (24) expr -> . expr + expr
    (25) expr -> . NAME
    (26) expr -> . NAME ASSIGN expr
    {               shift and go to state 8
    NULL            shift and go to state 9
    BOOLEAN         shift and go to state 10
    STRING          shift and go to state 11
    NUMBER          shift and go to state 12
    NOT             shift and go to state 13
    (               shift and go to state 6
    -               shift and go to state 14
    NAME            shift and go to state 7

    expr                           shift and go to state 31

state 14

    (19) expr -> - . expr
    (7) expr -> . expr . NAME
    (8) expr -> . { new_scope }
    (9) expr -> . { new_scope block }
    (10) expr -> . NULL
    (11) expr -> . BOOLEAN
    (12) expr -> . STRING
    (13) expr -> . NUMBER
    (14) expr -> . NOT expr
    (15) expr -> . expr EQ expr
    (16) expr -> . expr OR expr
    (17) expr -> . expr AND expr
    (18) expr -> . ( expr )
    (19) expr -> . - expr
    (20) expr -> . expr % expr
    (21) expr -> . expr / expr
    (22) expr -> . expr * expr
    (23) expr -> . expr - expr
    (24) expr -> . expr + expr
    (25) expr -> . NAME
    (26) expr -> . NAME ASSIGN expr
    {               shift and go to state 8
    NULL            shift and go to state 9
    BOOLEAN         shift and go to state 10
    STRING          shift and go to state 11
    NUMBER          shift and go to state 12
    NOT             shift and go to state 13
    (               shift and go to state 6
    -               shift and go to state 14
    NAME            shift and go to state 7

    expr                           shift and go to state 32

state 15

    (1) block -> block NEWLINE .
    NEWLINE         reduce using rule 1 (block -> block NEWLINE .)
    PRINT           reduce using rule 1 (block -> block NEWLINE .)
    {               reduce using rule 1 (block -> block NEWLINE .)
    NULL            reduce using rule 1 (block -> block NEWLINE .)
    BOOLEAN         reduce using rule 1 (block -> block NEWLINE .)
    STRING          reduce using rule 1 (block -> block NEWLINE .)
    NUMBER          reduce using rule 1 (block -> block NEWLINE .)
    NOT             reduce using rule 1 (block -> block NEWLINE .)
    (               reduce using rule 1 (block -> block NEWLINE .)
    -               reduce using rule 1 (block -> block NEWLINE .)
    NAME            reduce using rule 1 (block -> block NEWLINE .)
    $end            reduce using rule 1 (block -> block NEWLINE .)
    }               reduce using rule 1 (block -> block NEWLINE .)


state 16

    (3) block -> block stmt .
    NEWLINE         reduce using rule 3 (block -> block stmt .)
    PRINT           reduce using rule 3 (block -> block stmt .)
    {               reduce using rule 3 (block -> block stmt .)
    NULL            reduce using rule 3 (block -> block stmt .)
    BOOLEAN         reduce using rule 3 (block -> block stmt .)
    STRING          reduce using rule 3 (block -> block stmt .)
    NUMBER          reduce using rule 3 (block -> block stmt .)
    NOT             reduce using rule 3 (block -> block stmt .)
    (               reduce using rule 3 (block -> block stmt .)
    -               reduce using rule 3 (block -> block stmt .)
    NAME            reduce using rule 3 (block -> block stmt .)
    $end            reduce using rule 3 (block -> block stmt .)
    }               reduce using rule 3 (block -> block stmt .)


state 17

    (2) block -> NEWLINE block .
    (1) block -> block . NEWLINE
    (3) block -> block . stmt
    (5) stmt -> . expr
    (6) stmt -> . PRINT ( expr )
    (7) expr -> . expr . NAME
    (8) expr -> . { new_scope }
    (9) expr -> . { new_scope block }
    (10) expr -> . NULL
    (11) expr -> . BOOLEAN
    (12) expr -> . STRING
    (13) expr -> . NUMBER
    (14) expr -> . NOT expr
    (15) expr -> . expr EQ expr
    (16) expr -> . expr OR expr
    (17) expr -> . expr AND expr
    (18) expr -> . ( expr )
    (19) expr -> . - expr
    (20) expr -> . expr % expr
    (21) expr -> . expr / expr
    (22) expr -> . expr * expr
    (23) expr -> . expr - expr
    (24) expr -> . expr + expr
    (25) expr -> . NAME
    (26) expr -> . NAME ASSIGN expr
  ! shift/reduce conflict for NEWLINE resolved as shift
  ! shift/reduce conflict for PRINT resolved as shift
  ! shift/reduce conflict for { resolved as shift
  ! shift/reduce conflict for NULL resolved as shift
  ! shift/reduce conflict for BOOLEAN resolved as shift
  ! shift/reduce conflict for STRING resolved as shift
  ! shift/reduce conflict for NUMBER resolved as shift
  ! shift/reduce conflict for NOT resolved as shift
  ! shift/reduce conflict for ( resolved as shift
  ! shift/reduce conflict for - resolved as shift
  ! shift/reduce conflict for NAME resolved as shift
    $end            reduce using rule 2 (block -> NEWLINE block .)
    }               reduce using rule 2 (block -> NEWLINE block .)
    NEWLINE         shift and go to state 15
    PRINT           shift and go to state 5
    {               shift and go to state 8
    NULL            shift and go to state 9
    BOOLEAN         shift and go to state 10
    STRING          shift and go to state 11
    NUMBER          shift and go to state 12
    NOT             shift and go to state 13
    (               shift and go to state 6
    -               shift and go to state 14
    NAME            shift and go to state 7

    stmt                           shift and go to state 16
    expr                           shift and go to state 4

state 18

    (7) expr -> expr . . NAME
    NAME            shift and go to state 33


state 19

    (15) expr -> expr EQ . expr
    (7) expr -> . expr . NAME
    (8) expr -> . { new_scope }
    (9) expr -> . { new_scope block }
    (10) expr -> . NULL
    (11) expr -> . BOOLEAN
    (12) expr -> . STRING
    (13) expr -> . NUMBER
    (14) expr -> . NOT expr
    (15) expr -> . expr EQ expr
    (16) expr -> . expr OR expr
    (17) expr -> . expr AND expr
    (18) expr -> . ( expr )
    (19) expr -> . - expr
    (20) expr -> . expr % expr
    (21) expr -> . expr / expr
    (22) expr -> . expr * expr
    (23) expr -> . expr - expr
    (24) expr -> . expr + expr
    (25) expr -> . NAME
    (26) expr -> . NAME ASSIGN expr
    {               shift and go to state 8
    NULL            shift and go to state 9
    BOOLEAN         shift and go to state 10
    STRING          shift and go to state 11
    NUMBER          shift and go to state 12
    NOT             shift and go to state 13
    (               shift and go to state 6
    -               shift and go to state 14
    NAME            shift and go to state 7

    expr                           shift and go to state 34

state 20

    (16) expr -> expr OR . expr
    (7) expr -> . expr . NAME
    (8) expr -> . { new_scope }
    (9) expr -> . { new_scope block }
    (10) expr -> . NULL
    (11) expr -> . BOOLEAN
    (12) expr -> . STRING
    (13) expr -> . NUMBER
    (14) expr -> . NOT expr
    (15) expr -> . expr EQ expr
    (16) expr -> . expr OR expr
    (17) expr -> . expr AND expr
    (18) expr -> . ( expr )
    (19) expr -> . - expr
    (20) expr -> . expr % expr
    (21) expr -> . expr / expr
    (22) expr -> . expr * expr
    (23) expr -> . expr - expr
    (24) expr -> . expr + expr
    (25) expr -> . NAME
    (26) expr -> . NAME ASSIGN expr
    {               shift and go to state 8
    NULL            shift and go to state 9
    BOOLEAN         shift and go to state 10
    STRING          shift and go to state 11
    NUMBER          shift and go to state 12
    NOT             shift and go to state 13
    (               shift and go to state 6
    -               shift and go to state 14
    NAME            shift and go to state 7

    expr                           shift and go to state 35

state 21

    (17) expr -> expr AND . expr
    (7) expr -> . expr . NAME
    (8) expr -> . { new_scope }
    (9) expr -> . { new_scope block }
    (10) expr -> . NULL
    (11) expr -> . BOOLEAN
    (12) expr -> . STRING
    (13) expr -> . NUMBER
    (14) expr -> . NOT expr
    (15) expr -> . expr EQ expr
    (16) expr -> . expr OR expr
    (17) expr -> . expr AND expr
    (18) expr -> . ( expr )
    (19) expr -> . - expr
    (20) expr -> . expr % expr
    (21) expr -> . expr / expr
    (22) expr -> . expr * expr
    (23) expr -> . expr - expr
    (24) expr -> . expr + expr
    (25) expr -> . NAME
    (26) expr -> . NAME ASSIGN expr
    {               shift and go to state 8
    NULL            shift and go to state 9
    BOOLEAN         shift and go to state 10
    STRING          shift and go to state 11
    NUMBER          shift and go to state 12
    NOT             shift and go to state 13
    (               shift and go to state 6
    -               shift and go to state 14
    NAME            shift and go to state 7

    expr                           shift and go to state 36

state 22

    (20) expr -> expr % . expr
    (7) expr -> . expr . NAME
    (8) expr -> . { new_scope }
    (9) expr -> . { new_scope block }
    (10) expr -> . NULL
    (11) expr -> . BOOLEAN
    (12) expr -> . STRING
    (13) expr -> . NUMBER
    (14) expr -> . NOT expr
    (15) expr -> . expr EQ expr
    (16) expr -> . expr OR expr
    (17) expr -> . expr AND expr
    (18) expr -> . ( expr )
    (19) expr -> . - expr
    (20) expr -> . expr % expr
    (21) expr -> . expr / expr
    (22) expr -> . expr * expr
    (23) expr -> . expr - expr
    (24) expr -> . expr + expr
    (25) expr -> . NAME
    (26) expr -> . NAME ASSIGN expr
    {               shift and go to state 8
    NULL            shift and go to state 9
    BOOLEAN         shift and go to state 10
    STRING          shift and go to state 11
    NUMBER          shift and go to state 12
    NOT             shift and go to state 13
    (               shift and go to state 6
    -               shift and go to state 14
    NAME            shift and go to state 7

    expr                           shift and go to state 37

state 23

    (21) expr -> expr / . expr
    (7) expr -> . expr . NAME
    (8) expr -> . { new_scope }
    (9) expr -> . { new_scope block }
    (10) expr -> . NULL
    (11) expr -> . BOOLEAN
    (12) expr -> . STRING
    (13) expr -> . NUMBER
    (14) expr -> . NOT expr
    (15) expr -> . expr EQ expr
    (16) expr -> . expr OR expr
    (17) expr -> . expr AND expr
    (18) expr -> . ( expr )
    (19) expr -> . - expr
    (20) expr -> . expr % expr
    (21) expr -> . expr / expr
    (22) expr -> . expr * expr
    (23) expr -> . expr - expr
    (24) expr -> . expr + expr
    (25) expr -> . NAME
    (26) expr -> . NAME ASSIGN expr
    {               shift and go to state 8
    NULL            shift and go to state 9
    BOOLEAN         shift and go to state 10
    STRING          shift and go to state 11
    NUMBER          shift and go to state 12
    NOT             shift and go to state 13
    (               shift and go to state 6
    -               shift and go to state 14
    NAME            shift and go to state 7

    expr                           shift and go to state 38

state 24

    (22) expr -> expr * . expr
    (7) expr -> . expr . NAME
    (8) expr -> . { new_scope }
    (9) expr -> . { new_scope block }
    (10) expr -> . NULL
    (11) expr -> . BOOLEAN
    (12) expr -> . STRING
    (13) expr -> . NUMBER
    (14) expr -> . NOT expr
    (15) expr -> . expr EQ expr
    (16) expr -> . expr OR expr
    (17) expr -> . expr AND expr
    (18) expr -> . ( expr )
    (19) expr -> . - expr
    (20) expr -> . expr % expr
    (21) expr -> . expr / expr
    (22) expr -> . expr * expr
    (23) expr -> . expr - expr
    (24) expr -> . expr + expr
    (25) expr -> . NAME
    (26) expr -> . NAME ASSIGN expr
    {               shift and go to state 8
    NULL            shift and go to state 9
    BOOLEAN         shift and go to state 10
    STRING          shift and go to state 11
    NUMBER          shift and go to state 12
    NOT             shift and go to state 13
    (               shift and go to state 6
    -               shift and go to state 14
    NAME            shift and go to state 7

    expr                           shift and go to state 39

state 25

    (23) expr -> expr - . expr
    (7) expr -> . expr . NAME
    (8) expr -> . { new_scope }
    (9) expr -> . { new_scope block }
    (10) expr -> . NULL
    (11) expr -> . BOOLEAN
    (12) expr -> . STRING
    (13) expr -> . NUMBER
    (14) expr -> . NOT expr
    (15) expr -> . expr EQ expr
    (16) expr -> . expr OR expr
    (17) expr -> . expr AND expr
    (18) expr -> . ( expr )
    (19) expr -> . - expr
    (20) expr -> . expr % expr
    (21) expr -> . expr / expr
    (22) expr -> . expr * expr
    (23) expr -> . expr - expr
    (24) expr -> . expr + expr
    (25) expr -> . NAME
    (26) expr -> . NAME ASSIGN expr
    {               shift and go to state 8
    NULL            shift and go to state 9
    BOOLEAN         shift and go to state 10
    STRING          shift and go to state 11
    NUMBER          shift and go to state 12
    NOT             shift and go to state 13
    (               shift and go to state 6
    -               shift and go to state 14
    NAME            shift and go to state 7

    expr                           shift and go to state 40

state 26

    (24) expr -> expr + . expr
    (7) expr -> . expr . NAME
    (8) expr -> . { new_scope }
    (9) expr -> . { new_scope block }
    (10) expr -> . NULL
    (11) expr -> . BOOLEAN
    (12) expr -> . STRING
    (13) expr -> . NUMBER
    (14) expr -> . NOT expr
    (15) expr -> . expr EQ expr
    (16) expr -> . expr OR expr
    (17) expr -> . expr AND expr
    (18) expr -> . ( expr )
    (19) expr -> . - expr
    (20) expr -> . expr % expr
    (21) expr -> . expr / expr
    (22) expr -> . expr * expr
    (23) expr -> . expr - expr
    (24) expr -> . expr + expr
    (25) expr -> . NAME
    (26) expr -> . NAME ASSIGN expr
    {               shift and go to state 8
    NULL            shift and go to state 9
    BOOLEAN         shift and go to state 10
    STRING          shift and go to state 11
    NUMBER          shift and go to state 12
    NOT             shift and go to state 13
    (               shift and go to state 6
    -               shift and go to state 14
    NAME            shift and go to state 7

    expr                           shift and go to state 41

state 27

    (6) stmt -> PRINT ( . expr )
    (7) expr -> . expr . NAME
    (8) expr -> . { new_scope }
    (9) expr -> . { new_scope block }
    (10) expr -> . NULL
    (11) expr -> . BOOLEAN
    (12) expr -> . STRING
    (13) expr -> . NUMBER
    (14) expr -> . NOT expr
    (15) expr -> . expr EQ expr
    (16) expr -> . expr OR expr
    (17) expr -> . expr AND expr
    (18) expr -> . ( expr )
    (19) expr -> . - expr
    (20) expr -> . expr % expr
    (21) expr -> . expr / expr
    (22) expr -> . expr * expr
    (23) expr -> . expr - expr
    (24) expr -> . expr + expr
    (25) expr -> . NAME
    (26) expr -> . NAME ASSIGN expr
    {               shift and go to state 8
    NULL            shift and go to state 9
    BOOLEAN         shift and go to state 10
    STRING          shift and go to state 11
    NUMBER          shift and go to state 12
    NOT             shift and go to state 13
    (               shift and go to state 6
    -               shift and go to state 14
    NAME            shift and go to state 7

    expr                           shift and go to state 42

state 28

    (18) expr -> ( expr . )
    (7) expr -> expr . . NAME
    (15) expr -> expr . EQ expr
    (16) expr -> expr . OR expr
    (17) expr -> expr . AND expr
    (20) expr -> expr . % expr
    (21) expr -> expr . / expr
    (22) expr -> expr . * expr
    (23) expr -> expr . - expr
    (24) expr -> expr . + expr
    )               shift and go to state 43
    .               shift and go to state 18
    EQ              shift and go to state 19
    OR              shift and go to state 20
    AND             shift and go to state 21
    %               shift and go to state 22
    /               shift and go to state 23
    *               shift and go to state 24
    -               shift and go to state 25
    +               shift and go to state 26


state 29

    (26) expr -> NAME ASSIGN . expr
    (7) expr -> . expr . NAME
    (8) expr -> . { new_scope }
    (9) expr -> . { new_scope block }
    (10) expr -> . NULL
    (11) expr -> . BOOLEAN
    (12) expr -> . STRING
    (13) expr -> . NUMBER
    (14) expr -> . NOT expr
    (15) expr -> . expr EQ expr
    (16) expr -> . expr OR expr
    (17) expr -> . expr AND expr
    (18) expr -> . ( expr )
    (19) expr -> . - expr
    (20) expr -> . expr % expr
    (21) expr -> . expr / expr
    (22) expr -> . expr * expr
    (23) expr -> . expr - expr
    (24) expr -> . expr + expr
    (25) expr -> . NAME
    (26) expr -> . NAME ASSIGN expr
    {               shift and go to state 8
    NULL            shift and go to state 9
    BOOLEAN         shift and go to state 10
    STRING          shift and go to state 11
    NUMBER          shift and go to state 12
    NOT             shift and go to state 13
    (               shift and go to state 6
    -               shift and go to state 14
    NAME            shift and go to state 7

    expr                           shift and go to state 44

state 30

    (8) expr -> { new_scope . }
    (9) expr -> { new_scope . block }
    (1) block -> . block NEWLINE
    (2) block -> . NEWLINE block
    (3) block -> . block stmt
    (4) block -> . stmt
    (5) stmt -> . expr
    (6) stmt -> . PRINT ( expr )
    (7) expr -> . expr . NAME
    (8) expr -> . { new_scope }
    (9) expr -> . { new_scope block }
    (10) expr -> . NULL
    (11) expr -> . BOOLEAN
    (12) expr -> . STRING
    (13) expr -> . NUMBER
    (14) expr -> . NOT expr
    (15) expr -> . expr EQ expr
    (16) expr -> . expr OR expr
    (17) expr -> . expr AND expr
    (18) expr -> . ( expr )
    (19) expr -> . - expr
    (20) expr -> . expr % expr
    (21) expr -> . expr / expr
    (22) expr -> . expr * expr
    (23) expr -> . expr - expr
    (24) expr -> . expr + expr
    (25) expr -> . NAME
    (26) expr -> . NAME ASSIGN expr
    }               shift and go to state 45
    NEWLINE         shift and go to state 2
    PRINT           shift and go to state 5
    {               shift and go to state 8
    NULL            shift and go to state 9
    BOOLEAN         shift and go to state 10
    STRING          shift and go to state 11
    NUMBER          shift and go to state 12
    NOT             shift and go to state 13
    (               shift and go to state 6
    -               shift and go to state 14
    NAME            shift and go to state 7

    block                          shift and go to state 46
    stmt                           shift and go to state 3
    expr                           shift and go to state 4

state 31

    (14) expr -> NOT expr .
    (7) expr -> expr . . NAME
    (15) expr -> expr . EQ expr
    (16) expr -> expr . OR expr
    (17) expr -> expr . AND expr
    (20) expr -> expr . % expr
    (21) expr -> expr . / expr
    (22) expr -> expr . * expr
    (23) expr -> expr . - expr
    (24) expr -> expr . + expr
    EQ              reduce using rule 14 (expr -> NOT expr .)
    OR              reduce using rule 14 (expr -> NOT expr .)
    AND             reduce using rule 14 (expr -> NOT expr .)
    %               reduce using rule 14 (expr -> NOT expr .)
    /               reduce using rule 14 (expr -> NOT expr .)
    *               reduce using rule 14 (expr -> NOT expr .)
    -               reduce using rule 14 (expr -> NOT expr .)
    +               reduce using rule 14 (expr -> NOT expr .)
    NEWLINE         reduce using rule 14 (expr -> NOT expr .)
    PRINT           reduce using rule 14 (expr -> NOT expr .)
    {               reduce using rule 14 (expr -> NOT expr .)
    NULL            reduce using rule 14 (expr -> NOT expr .)
    BOOLEAN         reduce using rule 14 (expr -> NOT expr .)
    STRING          reduce using rule 14 (expr -> NOT expr .)
    NUMBER          reduce using rule 14 (expr -> NOT expr .)
    NOT             reduce using rule 14 (expr -> NOT expr .)
    (               reduce using rule 14 (expr -> NOT expr .)
    NAME            reduce using rule 14 (expr -> NOT expr .)
    $end            reduce using rule 14 (expr -> NOT expr .)
    }               reduce using rule 14 (expr -> NOT expr .)
    )               reduce using rule 14 (expr -> NOT expr .)
    .               shift and go to state 18


state 32

    (19) expr -> - expr .
    (7) expr -> expr . . NAME
    (15) expr -> expr . EQ expr
    (16) expr -> expr . OR expr
    (17) expr -> expr . AND expr
    (20) expr -> expr . % expr
    (21) expr -> expr . / expr
    (22) expr -> expr . * expr
    (23) expr -> expr . - expr
    (24) expr -> expr . + expr
    EQ              reduce using rule 19 (expr -> - expr .)
    OR              reduce using rule 19 (expr -> - expr .)
    AND             reduce using rule 19 (expr -> - expr .)
    %               reduce using rule 19 (expr -> - expr .)
    /               reduce using rule 19 (expr -> - expr .)
    *               reduce using rule 19 (expr -> - expr .)
    -               reduce using rule 19 (expr -> - expr .)
    +               reduce using rule 19 (expr -> - expr .)
    NEWLINE         reduce using rule 19 (expr -> - expr .)
    PRINT           reduce using rule 19 (expr -> - expr .)
    {               reduce using rule 19 (expr -> - expr .)
    NULL            reduce using rule 19 (expr -> - expr .)
    BOOLEAN         reduce using rule 19 (expr -> - expr .)
    STRING          reduce using rule 19 (expr -> - expr .)
    NUMBER          reduce using rule 19 (expr -> - expr .)
    NOT             reduce using rule 19 (expr -> - expr .)
    (               reduce using rule 19 (expr -> - expr .)
    NAME            reduce using rule 19 (expr -> - expr .)
    $end            reduce using rule 19 (expr -> - expr .)
    }               reduce using rule 19 (expr -> - expr .)
    )               reduce using rule 19 (expr -> - expr .)
    .               shift and go to state 18


state 33

    (7) expr -> expr . NAME .
    .               reduce using rule 7 (expr -> expr . NAME .)
    EQ              reduce using rule 7 (expr -> expr . NAME .)
    OR              reduce using rule 7 (expr -> expr . NAME .)
    AND             reduce using rule 7 (expr -> expr . NAME .)
    %               reduce using rule 7 (expr -> expr . NAME .)
    /               reduce using rule 7 (expr -> expr . NAME .)
    *               reduce using rule 7 (expr -> expr . NAME .)
    -               reduce using rule 7 (expr -> expr . NAME .)
    +               reduce using rule 7 (expr -> expr . NAME .)
    NEWLINE         reduce using rule 7 (expr -> expr . NAME .)
    PRINT           reduce using rule 7 (expr -> expr . NAME .)
    {               reduce using rule 7 (expr -> expr . NAME .)
    NULL            reduce using rule 7 (expr -> expr . NAME .)
    BOOLEAN         reduce using rule 7 (expr -> expr . NAME .)
    STRING          reduce using rule 7 (expr -> expr . NAME .)
    NUMBER          reduce using rule 7 (expr -> expr . NAME .)
    NOT             reduce using rule 7 (expr -> expr . NAME .)
    (               reduce using rule 7 (expr -> expr . NAME .)
    NAME            reduce using rule 7 (expr -> expr . NAME .)
    $end            reduce using rule 7 (expr -> expr . NAME .)
    }               reduce using rule 7 (expr -> expr . NAME .)
    )               reduce using rule 7 (expr -> expr . NAME .)


state 34

    (15) expr -> expr EQ expr .
    (7) expr -> expr . . NAME
    (15) expr -> expr . EQ expr
    (16) expr -> expr . OR expr
    (17) expr -> expr . AND expr
    (20) expr -> expr . % expr
    (21) expr -> expr . / expr
    (22) expr -> expr . * expr
    (23) expr -> expr . - expr
    (24) expr -> expr . + expr
    EQ              reduce using rule 15 (expr -> expr EQ expr .)
    OR              reduce using rule 15 (expr -> expr EQ expr .)
    AND             reduce using rule 15 (expr -> expr EQ expr .)
    NEWLINE         reduce using rule 15 (expr -> expr EQ expr .)
    PRINT           reduce using rule 15 (expr -> expr EQ expr .)
    {               reduce using rule 15 (expr -> expr EQ expr .)
    NULL            reduce using rule 15 (expr -> expr EQ expr .)
    BOOLEAN         reduce using rule 15 (expr -> expr EQ expr .)
    STRING          reduce using rule 15 (expr -> expr EQ expr .)
    NUMBER          reduce using rule 15 (expr -> expr EQ expr .)
    NOT             reduce using rule 15 (expr -> expr EQ expr .)
    (               reduce using rule 15 (expr -> expr EQ expr .)
    NAME            reduce using rule 15 (expr -> expr EQ expr .)
    $end            reduce using rule 15 (expr -> expr EQ expr .)
    }               reduce using rule 15 (expr -> expr EQ expr .)
    )               reduce using rule 15 (expr -> expr EQ expr .)
    .               shift and go to state 18
    %               shift and go to state 22
    /               shift and go to state 23
    *               shift and go to state 24
    -               shift and go to state 25
    +               shift and go to state 26


state 35

    (16) expr -> expr OR expr .
    (7) expr -> expr . . NAME
    (15) expr -> expr . EQ expr
    (16) expr -> expr . OR expr
    (17) expr -> expr . AND expr
    (20) expr -> expr . % expr
    (21) expr -> expr . / expr
    (22) expr -> expr . * expr
    (23) expr -> expr . - expr
    (24) expr -> expr . + expr
    OR              reduce using rule 16 (expr -> expr OR expr .)
    AND             reduce using rule 16 (expr -> expr OR expr .)
    NEWLINE         reduce using rule 16 (expr -> expr OR expr .)
    PRINT           reduce using rule 16 (expr -> expr OR expr .)
    {               reduce using rule 16 (expr -> expr OR expr .)
    NULL            reduce using rule 16 (expr -> expr OR expr .)
    BOOLEAN         reduce using rule 16 (expr -> expr OR expr .)
    STRING          reduce using rule 16 (expr -> expr OR expr .)
    NUMBER          reduce using rule 16 (expr -> expr OR expr .)
    NOT             reduce using rule 16 (expr -> expr OR expr .)
    (               reduce using rule 16 (expr -> expr OR expr .)
    NAME            reduce using rule 16 (expr -> expr OR expr .)
    $end            reduce using rule 16 (expr -> expr OR expr .)
    }               reduce using rule 16 (expr -> expr OR expr .)
    )               reduce using rule 16 (expr -> expr OR expr .)
    .               shift and go to state 18
    EQ              shift and go to state 19
    %               shift and go to state 22
    /               shift and go to state 23
    *               shift and go to state 24
    -               shift and go to state 25
    +               shift and go to state 26


state 36

    (17) expr -> expr AND expr .
    (7) expr -> expr . . NAME
    (15) expr -> expr . EQ expr
    (16) expr -> expr . OR expr
    (17) expr -> expr . AND expr
    (20) expr -> expr . % expr
    (21) expr -> expr . / expr
    (22) expr -> expr . * expr
    (23) expr -> expr . - expr
    (24) expr -> expr . + expr
    OR              reduce using rule 17 (expr -> expr AND expr .)
    AND             reduce using rule 17 (expr -> expr AND expr .)
    NEWLINE         reduce using rule 17 (expr -> expr AND expr .)
    PRINT           reduce using rule 17 (expr -> expr AND expr .)
    {               reduce using rule 17 (expr -> expr AND expr .)
    NULL            reduce using rule 17 (expr -> expr AND expr .)
    BOOLEAN         reduce using rule 17 (expr -> expr AND expr .)
    STRING          reduce using rule 17 (expr -> expr AND expr .)
    NUMBER          reduce using rule 17 (expr -> expr AND expr .)
    NOT             reduce using rule 17 (expr -> expr AND expr .)
    (               reduce using rule 17 (expr -> expr AND expr .)
    NAME            reduce using rule 17 (expr -> expr AND expr .)
    $end            reduce using rule 17 (expr -> expr AND expr .)
    }               reduce using rule 17 (expr -> expr AND expr .)
    )               reduce using rule 17 (expr -> expr AND expr .)
    .               shift and go to state 18
    EQ              shift and go to state 19
    %               shift and go to state 22
    /               shift and go to state 23
    *               shift and go to state 24
    -               shift and go to state 25
    +               shift and go to state 26


state 37

    (20) expr -> expr % expr .
    (7) expr -> expr . . NAME
    (15) expr -> expr . EQ expr
    (16) expr -> expr . OR expr
    (17) expr -> expr . AND expr
    (20) expr -> expr . % expr
    (21) expr -> expr . / expr
    (22) expr -> expr . * expr
    (23) expr -> expr . - expr
    (24) expr -> expr . + expr
    EQ              reduce using rule 20 (expr -> expr % expr .)
    OR              reduce using rule 20 (expr -> expr % expr .)
    AND             reduce using rule 20 (expr -> expr % expr .)
    %               reduce using rule 20 (expr -> expr % expr .)
    /               reduce using rule 20 (expr -> expr % expr .)
    *               reduce using rule 20 (expr -> expr % expr .)
    -               reduce using rule 20 (expr -> expr % expr .)
    +               reduce using rule 20 (expr -> expr % expr .)
    NEWLINE         reduce using rule 20 (expr -> expr % expr .)
    PRINT           reduce using rule 20 (expr -> expr % expr .)
    {               reduce using rule 20 (expr -> expr % expr .)
    NULL            reduce using rule 20 (expr -> expr % expr .)
    BOOLEAN         reduce using rule 20 (expr -> expr % expr .)
    STRING          reduce using rule 20 (expr -> expr % expr .)
    NUMBER          reduce using rule 20 (expr -> expr % expr .)
    NOT             reduce using rule 20 (expr -> expr % expr .)
    (               reduce using rule 20 (expr -> expr % expr .)
    NAME            reduce using rule 20 (expr -> expr % expr .)
    $end            reduce using rule 20 (expr -> expr % expr .)
    }               reduce using rule 20 (expr -> expr % expr .)
    )               reduce using rule 20 (expr -> expr % expr .)
    .               shift and go to state 18


state 38

    (21) expr -> expr / expr .
    (7) expr -> expr . . NAME
    (15) expr -> expr . EQ expr
    (16) expr -> expr . OR expr
    (17) expr -> expr . AND expr
    (20) expr -> expr . % expr
    (21) expr -> expr . / expr
    (22) expr -> expr . * expr
    (23) expr -> expr . - expr
    (24) expr -> expr . + expr
    EQ              reduce using rule 21 (expr -> expr / expr .)
    OR              reduce using rule 21 (expr -> expr / expr .)
    AND             reduce using rule 21 (expr -> expr / expr .)
    %               reduce using rule 21 (expr -> expr / expr .)
    /               reduce using rule 21 (expr -> expr / expr .)
    *               reduce using rule 21 (expr -> expr / expr .)
    -               reduce using rule 21 (expr -> expr / expr .)
    +               reduce using rule 21 (expr -> expr / expr .)
    NEWLINE         reduce using rule 21 (expr -> expr / expr .)
    PRINT           reduce using rule 21 (expr -> expr / expr .)
    {               reduce using rule 21 (expr -> expr / expr .)
    NULL            reduce using rule 21 (expr -> expr / expr .)
    BOOLEAN         reduce using rule 21 (expr -> expr / expr .)
    STRING          reduce using rule 21 (expr -> expr / expr .)
    NUMBER          reduce using rule 21 (expr -> expr / expr .)
    NOT             reduce using rule 21 (expr -> expr / expr .)
    (               reduce using rule 21 (expr -> expr / expr .)
    NAME            reduce using rule 21 (expr -> expr / expr .)
    $end            reduce using rule 21 (expr -> expr / expr .)
    }               reduce using rule 21 (expr -> expr / expr .)
    )               reduce using rule 21 (expr -> expr / expr .)
    .               shift and go to state 18


state 39

    (22) expr -> expr * expr .
    (7) expr -> expr . . NAME
    (15) expr -> expr . EQ expr
    (16) expr -> expr . OR expr
    (17) expr -> expr . AND expr
    (20) expr -> expr . % expr
    (21) expr -> expr . / expr
    (22) expr -> expr . * expr
    (23) expr -> expr . - expr
    (24) expr -> expr . + expr
    EQ              reduce using rule 22 (expr -> expr * expr .)
    OR              reduce using rule 22 (expr -> expr * expr .)
    AND             reduce using rule 22 (expr -> expr * expr .)
    %               reduce using rule 22 (expr -> expr * expr .)
    /               reduce using rule 22 (expr -> expr * expr .)
    *               reduce using rule 22 (expr -> expr * expr .)
    -               reduce using rule 22 (expr -> expr * expr .)
    +               reduce using rule 22 (expr -> expr * expr .)
    NEWLINE         reduce using rule 22 (expr -> expr * expr .)
    PRINT           reduce using rule 22 (expr -> expr * expr .)
    {               reduce using rule 22 (expr -> expr * expr .)
    NULL            reduce using rule 22 (expr -> expr * expr .)
    BOOLEAN         reduce using rule 22 (expr -> expr * expr .)
    STRING          reduce using rule 22 (expr -> expr * expr .)
    NUMBER          reduce using rule 22 (expr -> expr * expr .)
    NOT             reduce using rule 22 (expr -> expr * expr .)
    (               reduce using rule 22 (expr -> expr * expr .)
    NAME            reduce using rule 22 (expr -> expr * expr .)
    $end            reduce using rule 22 (expr -> expr * expr .)
    }               reduce using rule 22 (expr -> expr * expr .)
    )               reduce using rule 22 (expr -> expr * expr .)
    .               shift and go to state 18


state 40

    (23) expr -> expr - expr .
    (7) expr -> expr . . NAME
    (15) expr -> expr . EQ expr
    (16) expr -> expr . OR expr
    (17) expr -> expr . AND expr
    (20) expr -> expr . % expr
    (21) expr -> expr . / expr
    (22) expr -> expr . * expr
    (23) expr -> expr . - expr
    (24) expr -> expr . + expr
    EQ              reduce using rule 23 (expr -> expr - expr .)
    OR              reduce using rule 23 (expr -> expr - expr .)
    AND             reduce using rule 23 (expr -> expr - expr .)
    -               reduce using rule 23 (expr -> expr - expr .)
    +               reduce using rule 23 (expr -> expr - expr .)
    NEWLINE         reduce using rule 23 (expr -> expr - expr .)
    PRINT           reduce using rule 23 (expr -> expr - expr .)
    {               reduce using rule 23 (expr -> expr - expr .)
    NULL            reduce using rule 23 (expr -> expr - expr .)
    BOOLEAN         reduce using rule 23 (expr -> expr - expr .)
    STRING          reduce using rule 23 (expr -> expr - expr .)
    NUMBER          reduce using rule 23 (expr -> expr - expr .)
    NOT             reduce using rule 23 (expr -> expr - expr .)
    (               reduce using rule 23 (expr -> expr - expr .)
    NAME            reduce using rule 23 (expr -> expr - expr .)
    $end            reduce using rule 23 (expr -> expr - expr .)
    }               reduce using rule 23 (expr -> expr - expr .)
    )               reduce using rule 23 (expr -> expr - expr .)
    .               shift and go to state 18
    %               shift and go to state 22
    /               shift and go to state 23
    *               shift and go to state 24


state 41

    (24) expr -> expr + expr .
    (7) expr -> expr . . NAME
    (15) expr -> expr . EQ expr
    (16) expr -> expr . OR expr
    (17) expr -> expr . AND expr
    (20) expr -> expr . % expr
    (21) expr -> expr . / expr
    (22) expr -> expr . * expr
    (23) expr -> expr . - expr
    (24) expr -> expr . + expr
    EQ              reduce using rule 24 (expr -> expr + expr .)
    OR              reduce using rule 24 (expr -> expr + expr .)
    AND             reduce using rule 24 (expr -> expr + expr .)
    -               reduce using rule 24 (expr -> expr + expr .)
    +               reduce using rule 24 (expr -> expr + expr .)
    NEWLINE         reduce using rule 24 (expr -> expr + expr .)
    PRINT           reduce using rule 24 (expr -> expr + expr .)
    {               reduce using rule 24 (expr -> expr + expr .)
    NULL            reduce using rule 24 (expr -> expr + expr .)
    BOOLEAN         reduce using rule 24 (expr -> expr + expr .)
    STRING          reduce using rule 24 (expr -> expr + expr .)
    NUMBER          reduce using rule 24 (expr -> expr + expr .)
    NOT             reduce using rule 24 (expr -> expr + expr .)
    (               reduce using rule 24 (expr -> expr + expr .)
    NAME            reduce using rule 24 (expr -> expr + expr .)
    $end            reduce using rule 24 (expr -> expr + expr .)
    }               reduce using rule 24 (expr -> expr + expr .)
    )               reduce using rule 24 (expr -> expr + expr .)
    .               shift and go to state 18
    %               shift and go to state 22
    /               shift and go to state 23
    *               shift and go to state 24


state 42

    (6) stmt -> PRINT ( expr . )
    (7) expr -> expr . . NAME
    (15) expr -> expr . EQ expr
    (16) expr -> expr . OR expr
    (17) expr -> expr . AND expr
    (20) expr -> expr . % expr
    (21) expr -> expr . / expr
    (22) expr -> expr . * expr
    (23) expr -> expr . - expr
    (24) expr -> expr . + expr
    )               shift and go to state 47
    .               shift and go to state 18
    EQ              shift and go to state 19
    OR              shift and go to state 20
    AND             shift and go to state 21
    %               shift and go to state 22
    /               shift and go to state 23
    *               shift and go to state 24
    -               shift and go to state 25
    +               shift and go to state 26


state 43

    (18) expr -> ( expr ) .
    .               reduce using rule 18 (expr -> ( expr ) .)
    EQ              reduce using rule 18 (expr -> ( expr ) .)
    OR              reduce using rule 18 (expr -> ( expr ) .)
    AND             reduce using rule 18 (expr -> ( expr ) .)
    %               reduce using rule 18 (expr -> ( expr ) .)
    /               reduce using rule 18 (expr -> ( expr ) .)
    *               reduce using rule 18 (expr -> ( expr ) .)
    -               reduce using rule 18 (expr -> ( expr ) .)
    +               reduce using rule 18 (expr -> ( expr ) .)
    NEWLINE         reduce using rule 18 (expr -> ( expr ) .)
    PRINT           reduce using rule 18 (expr -> ( expr ) .)
    {               reduce using rule 18 (expr -> ( expr ) .)
    NULL            reduce using rule 18 (expr -> ( expr ) .)
    BOOLEAN         reduce using rule 18 (expr -> ( expr ) .)
    STRING          reduce using rule 18 (expr -> ( expr ) .)
    NUMBER          reduce using rule 18 (expr -> ( expr ) .)
    NOT             reduce using rule 18 (expr -> ( expr ) .)
    (               reduce using rule 18 (expr -> ( expr ) .)
    NAME            reduce using rule 18 (expr -> ( expr ) .)
    $end            reduce using rule 18 (expr -> ( expr ) .)
    }               reduce using rule 18 (expr -> ( expr ) .)
    )               reduce using rule 18 (expr -> ( expr ) .)


state 44

    (26) expr -> NAME ASSIGN expr .
    (7) expr -> expr . . NAME
    (15) expr -> expr . EQ expr
    (16) expr -> expr . OR expr
    (17) expr -> expr . AND expr
    (20) expr -> expr . % expr
    (21) expr -> expr . / expr
    (22) expr -> expr . * expr
    (23) expr -> expr . - expr
    (24) expr -> expr . + expr
  ! shift/reduce conflict for . resolved as shift
  ! shift/reduce conflict for EQ resolved as shift
  ! shift/reduce conflict for OR resolved as shift
  ! shift/reduce conflict for AND resolved as shift
  ! shift/reduce conflict for % resolved as shift
  ! shift/reduce conflict for / resolved as shift
  ! shift/reduce conflict for * resolved as shift
  ! shift/reduce conflict for - resolved as shift
  ! shift/reduce conflict for + resolved as shift
    NEWLINE         reduce using rule 26 (expr -> NAME ASSIGN expr .)
    PRINT           reduce using rule 26 (expr -> NAME ASSIGN expr .)
    {               reduce using rule 26 (expr -> NAME ASSIGN expr .)
    NULL            reduce using rule 26 (expr -> NAME ASSIGN expr .)
    BOOLEAN         reduce using rule 26 (expr -> NAME ASSIGN expr .)
    STRING          reduce using rule 26 (expr -> NAME ASSIGN expr .)
    NUMBER          reduce using rule 26 (expr -> NAME ASSIGN expr .)
    NOT             reduce using rule 26 (expr -> NAME ASSIGN expr .)
    (               reduce using rule 26 (expr -> NAME ASSIGN expr .)
    NAME            reduce using rule 26 (expr -> NAME ASSIGN expr .)
    $end            reduce using rule 26 (expr -> NAME ASSIGN expr .)
    }               reduce using rule 26 (expr -> NAME ASSIGN expr .)
    )               reduce using rule 26 (expr -> NAME ASSIGN expr .)
    .               shift and go to state 18
    EQ              shift and go to state 19
    OR              shift and go to state 20
    AND             shift and go to state 21
    %               shift and go to state 22
    /               shift and go to state 23
    *               shift and go to state 24
    -               shift and go to state 25
    +               shift and go to state 26


state 45

    (8) expr -> { new_scope } .
    .               reduce using rule 8 (expr -> { new_scope } .)
    EQ              reduce using rule 8 (expr -> { new_scope } .)
    OR              reduce using rule 8 (expr -> { new_scope } .)
    AND             reduce using rule 8 (expr -> { new_scope } .)
    %               reduce using rule 8 (expr -> { new_scope } .)
    /               reduce using rule 8 (expr -> { new_scope } .)
    *               reduce using rule 8 (expr -> { new_scope } .)
    -               reduce using rule 8 (expr -> { new_scope } .)
    +               reduce using rule 8 (expr -> { new_scope } .)
    NEWLINE         reduce using rule 8 (expr -> { new_scope } .)
    PRINT           reduce using rule 8 (expr -> { new_scope } .)
    {               reduce using rule 8 (expr -> { new_scope } .)
    NULL            reduce using rule 8 (expr -> { new_scope } .)
    BOOLEAN         reduce using rule 8 (expr -> { new_scope } .)
    STRING          reduce using rule 8 (expr -> { new_scope } .)
    NUMBER          reduce using rule 8 (expr -> { new_scope } .)
    NOT             reduce using rule 8 (expr -> { new_scope } .)
    (               reduce using rule 8 (expr -> { new_scope } .)
    NAME            reduce using rule 8 (expr -> { new_scope } .)
    $end            reduce using rule 8 (expr -> { new_scope } .)
    }               reduce using rule 8 (expr -> { new_scope } .)
    )               reduce using rule 8 (expr -> { new_scope } .)


state 46

    (9) expr -> { new_scope block . }
    (1) block -> block . NEWLINE
    (3) block -> block . stmt
    (5) stmt -> . expr
    (6) stmt -> . PRINT ( expr )
    (7) expr -> . expr . NAME
    (8) expr -> . { new_scope }
    (9) expr -> . { new_scope block }
    (10) expr -> . NULL
    (11) expr -> . BOOLEAN
    (12) expr -> . STRING
    (13) expr -> . NUMBER
    (14) expr -> . NOT expr
    (15) expr -> . expr EQ expr
    (16) expr -> . expr OR expr
    (17) expr -> . expr AND expr
    (18) expr -> . ( expr )
    (19) expr -> . - expr
    (20) expr -> . expr % expr
    (21) expr -> . expr / expr
    (22) expr -> . expr * expr
    (23) expr -> . expr - expr
    (24) expr -> . expr + expr
    (25) expr -> . NAME
    (26) expr -> . NAME ASSIGN expr
    }               shift and go to state 48
    NEWLINE         shift and go to state 15
    PRINT           shift and go to state 5
    {               shift and go to state 8
    NULL            shift and go to state 9
    BOOLEAN         shift and go to state 10
    STRING          shift and go to state 11
    NUMBER          shift and go to state 12
    NOT             shift and go to state 13
    (               shift and go to state 6
    -               shift and go to state 14
    NAME            shift and go to state 7

    stmt                           shift and go to state 16
    expr                           shift and go to state 4

state 47

    (6) stmt -> PRINT ( expr ) .
    NEWLINE         reduce using rule 6 (stmt -> PRINT ( expr ) .)
    PRINT           reduce using rule 6 (stmt -> PRINT ( expr ) .)
    {               reduce using rule 6 (stmt -> PRINT ( expr ) .)
    NULL            reduce using rule 6 (stmt -> PRINT ( expr ) .)
    BOOLEAN         reduce using rule 6 (stmt -> PRINT ( expr ) .)
    STRING          reduce using rule 6 (stmt -> PRINT ( expr ) .)
    NUMBER          reduce using rule 6 (stmt -> PRINT ( expr ) .)
    NOT             reduce using rule 6 (stmt -> PRINT ( expr ) .)
    (               reduce using rule 6 (stmt -> PRINT ( expr ) .)
    -               reduce using rule 6 (stmt -> PRINT ( expr ) .)
    NAME            reduce using rule 6 (stmt -> PRINT ( expr ) .)
    $end            reduce using rule 6 (stmt -> PRINT ( expr ) .)
    }               reduce using rule 6 (stmt -> PRINT ( expr ) .)


state 48

    (9) expr -> { new_scope block } .
    .               reduce using rule 9 (expr -> { new_scope block } .)
    EQ              reduce using rule 9 (expr -> { new_scope block } .)
    OR              reduce using rule 9 (expr -> { new_scope block } .)
    AND             reduce using rule 9 (expr -> { new_scope block } .)
    %               reduce using rule 9 (expr -> { new_scope block } .)
    /               reduce using rule 9 (expr -> { new_scope block } .)
    *               reduce using rule 9 (expr -> { new_scope block } .)
    -               reduce using rule 9 (expr -> { new_scope block } .)
    +               reduce using rule 9 (expr -> { new_scope block } .)
    NEWLINE         reduce using rule 9 (expr -> { new_scope block } .)
    PRINT           reduce using rule 9 (expr -> { new_scope block } .)
    {               reduce using rule 9 (expr -> { new_scope block } .)
    NULL            reduce using rule 9 (expr -> { new_scope block } .)
    BOOLEAN         reduce using rule 9 (expr -> { new_scope block } .)
    STRING          reduce using rule 9 (expr -> { new_scope block } .)
    NUMBER          reduce using rule 9 (expr -> { new_scope block } .)
    NOT             reduce using rule 9 (expr -> { new_scope block } .)
    (               reduce using rule 9 (expr -> { new_scope block } .)
    NAME            reduce using rule 9 (expr -> { new_scope block } .)
    $end            reduce using rule 9 (expr -> { new_scope block } .)
    }               reduce using rule 9 (expr -> { new_scope block } .)
    )               reduce using rule 9 (expr -> { new_scope block } .)


Conflicts:

shift/reduce conflict for - in state 4 resolved as shift
shift/reduce conflict for NEWLINE in state 17 resolved as shift
shift/reduce conflict for PRINT in state 17 resolved as shift
shift/reduce conflict for { in state 17 resolved as shift
shift/reduce conflict for NULL in state 17 resolved as shift
shift/reduce conflict for BOOLEAN in state 17 resolved as shift
shift/reduce conflict for STRING in state 17 resolved as shift
shift/reduce conflict for NUMBER in state 17 resolved as shift
shift/reduce conflict for NOT in state 17 resolved as shift
shift/reduce conflict for ( in state 17 resolved as shift
shift/reduce conflict for - in state 17 resolved as shift
shift/reduce conflict for NAME in state 17 resolved as shift
shift/reduce conflict for . in state 44 resolved as shift
shift/reduce conflict for EQ in state 44 resolved as shift
shift/reduce conflict for OR in state 44 resolved as shift
shift/reduce conflict for AND in state 44 resolved as shift
shift/reduce conflict for % in state 44 resolved as shift
shift/reduce conflict for / in state 44 resolved as shift
shift/reduce conflict for * in state 44 resolved as shift
shift/reduce conflict for - in state 44 resolved as shift
shift/reduce conflict for + in state 44 resolved as shift